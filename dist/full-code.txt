//File content ./src/types/connection-descriptor.ts
import NodeElement from "../architecture/node";
import Connection from "../architecture/connection";

export interface IConnectionDescriptor {
  in: (NodeElement | Connection)[];
  out: (NodeElement | Connection)[];
  self: (NodeElement | Connection)[];
  gated?: Connection[];
}
//File content ./src/types/activation-types.ts
import {ICommonCollection} from "./common-collection";

export type IActivationFunction = (x: number, derivate?: boolean) => number;
export type IActivationCollection = ICommonCollection<IActivationFunction>;//File content ./src/types/methods-gating-types.ts
import {ICommonCollection} from "./common-collection";

export interface IGate {
  name: string;
}
export type IGateCollection = ICommonCollection<IGate>;
//File content ./src/types/common-collection.ts
export type ICommonCollection<T> = {[key: string]: T}
//File content ./src/types/node-type-enum.ts
export enum NodeTypeEnum {
  input = 'input',
  hidden = 'hidden',
  output = 'output',
  constant = 'constant'
}
//File content ./src/types/methods-collection-types.ts
import {ICommonCollection} from "./common-collection";

export type IConnectionDescription = {name: string};
export type IConncetionCollection = ICommonCollection<IConnectionDescription>;//File content ./src/methods/cost.ts
import {ICommonCollection} from "../types/common-collection";

export type ICostFunction = (target: number[], output: number[]) => number;
type ICostCollection = ICommonCollection<ICostFunction>;

// https://en.wikipedia.org/wiki/Loss_function
const cost: ICostCollection = {
  // Cross entropy error
  CROSS_ENTROPY: function (target, output) {
    let error: number = 0;
    for (let i = 0; i < output.length; i++) {
      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A
      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));
    }
    return error / output.length;
  },
  // Mean Squared Error
  MSE: function (target, output) {
    let error = 0;
    for (let i = 0; i < output.length; i++) {
      error += Math.pow(target[i] - output[i], 2);
    }

    return error / output.length;
  },
  // Binary error
  BINARY: function (target, output) {
    let misses: number = 0;
    for (let i = 0; i < output.length; i++) {
      misses = misses + Number(Math.round(target[i] * 2) !== Math.round(output[i] * 2));
    }

    return misses;
  },
  // Mean Absolute Error
  MAE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs(target[i] - output[i]);
    }

    return error / output.length;
  },
  // Mean Absolute Percentage Error
  MAPE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));
    }

    return error / output.length;
  },
  // Mean Squared Logarithmic Error
  MSLE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));
    }

    return error;
  },
  // Hinge loss, for classifiers
  HINGE: function (target, output) {
    var error = 0;
    for (var i = 0; i < output.length; i++) {
      error += Math.max(0, 1 - target[i] * output[i]);
    }

    return error;
  }
};

export default cost;
//File content ./src/methods/selection.ts
import {ICommonCollection} from "../types/common-collection";

export type ISelection = {
  name: string;
  power?: number;
  size?: number;
  probability?: number;
};
type ISelectionsCollection = ICommonCollection<ISelection>;

// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)

const selection:ISelectionsCollection = {
  FITNESS_PROPORTIONATE: {
    name: 'FITNESS_PROPORTIONATE'
  },
  POWER: {
    name: 'POWER',
    power: 4
  },
  TOURNAMENT: {
    name: 'TOURNAMENT',
    size: 5,
    probability: 0.5
  }
};

export default selection;
//File content ./src/methods/mutation/add-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

const addConn: IMutation = {
  name: 'ADD_CONN',
  callback(network: Network) {
    // Create an array of all uncreated (feedforward) connections
    let available = [];
    for (let i = 0; i < network.nodes.length - network.output; i++) {
      let node1 = network.nodes[i];
      for (let j = Math.max(i + 1, network.input); j < network.nodes.length; j++) {
        let node2 = network.nodes[j];
        if (!node1.isProjectingTo(node2)) available.push([node1, node2]);
      }
    }

    if (available.length === 0) {
      if (config.warnings) console.warn('No more connections to be made!');
      return
    }

    let pair = available[Math.floor(Math.random() * available.length)];
    network.connect(pair[0], pair[1]);
  }
};

export default addConn;
//File content ./src/methods/mutation/add-node.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import NodeElement from "../../architecture/node";
import {NodeTypeEnum} from "../../types/node-type-enum";
import modActivation from "./mod-activation";

const addNode: IMutation = {
  name: 'ADD_NODE',
  callback(network: Network) {
    // Look for an existing connection and place a node in between
    let connection = network.connections[Math.floor(Math.random() * network.connections.length)];
    let gater, from, to;
    if (connection) {
      gater = connection.gater;
      from = connection.from;
      to = connection.to;

      network.disconnect(from, to);
    } else {
      from = network.nodes.find((node) => node.type === NodeTypeEnum.input) as NodeElement;
      to = network.nodes.find((node) => node.type === NodeTypeEnum.output) as NodeElement;
    }

    // Insert the new node right before the old connection.to
    let toIndex = network.nodes.indexOf(to);
    let node = new NodeElement(NodeTypeEnum.hidden);

    // Random squash function
    modActivation.mutateNode(node);

    // Place it in this.nodes
    let minBound = Math.min(toIndex, network.nodes.length - network.output);
    network.nodes.splice(minBound, 0, node);

    // Now create two new connections
    let newConn1 = network.connect(from, node)[0];
    let newConn2 = network.connect(node, to)[0];

    // Check if the original connection was gated
    if (gater != null) {
      network.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);
    }
  }
};

export default addNode;
//File content ./src/methods/mutation/add-back-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

const addBackConn: IMutation = {
  name: 'ADD_BACK_CONN',
  callback(network: Network) {
    // Create an array of all uncreated (backfed) connections
    let available = [];
    for (let i = network.input; i < network.nodes.length; i++) {
      let node1 = network.nodes[i];
      for (let j = network.input; j < i; j++) {
        let node2 = network.nodes[j];
        if (!node1.isProjectingTo(node2)) {
          available.push([node1, node2]);
        }
      }
    }

    if (available.length === 0) {
      if (config.warnings) console.warn('No more connections to be made!');
      return
    }

    let pair = available[Math.floor(Math.random() * available.length)];
    network.connect(pair[0], pair[1]);
  }
};

export default addBackConn;
//File content ./src/methods/mutation/sub-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

const subConn: IMutation = {
  name: 'SUB_CONN',
  callback(network: Network) {
    // List of possible connections that can be removed
    let possible = [];

    for (let i = 0; i < network.connections.length; i++) {
      let conn = network.connections[i];
      // Check if it is not disabling a node
      if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && network.nodes.indexOf(conn.to) > network.nodes.indexOf(conn.from)) {
        possible.push(conn);
      }
    }

    if (possible.length === 0) {
      if (config.warnings) console.warn('No connections to remove!');
      return
    }

    let randomConn = possible[Math.floor(Math.random() * possible.length)];
    network.disconnect(randomConn.from, randomConn.to);
  }
};

export default subConn;
//File content ./src/methods/mutation/sub-node.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

interface IMutationSubNode extends IMutation {
  keep_gates: boolean;
}

const subNode: IMutationSubNode = {
  name: 'SUB_NODE',
  callback(network: Network) {
    // Check if there are nodes left to remove
    if (network.nodes.length === network.input + network.output) {
      if (config.warnings) console.warn('No more nodes left to remove!');
      return;
    }

    // Select a node which isn't an input or output node
    let index = Math.floor(Math.random() * (network.nodes.length - network.output - network.input) + network.input);
    network.remove(network.nodes[index]);
  },
  keep_gates: true
};

export default subNode;
//File content ./src/methods/mutation/sub-self-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

const subSelfConn: IMutation = {
  name: 'SUB_SELF_CONN',
  callback(network: Network) {
    if (network.selfconns.length === 0) {
      if (config.warnings) console.warn('No more self-connections to remove!');
      return
    }
    const conn = network.selfconns[Math.floor(Math.random() * network.selfconns.length)];
    network.disconnect(conn.from, conn.to);
  }
};

export default subSelfConn;
//File content ./src/methods/mutation/mod-activation.ts
import {IMutation} from "./index";
import activation from "../activation";
import Network from "../../architecture/network";
import config from "../../config";
import {IActivationFunction} from "../../types/activation-types";
import NodeElement from "../../architecture/node";

export interface IMutationModActivation extends IMutation {
  mutateOutput: boolean;
  allowed: IActivationFunction[];
  mutateNode: (node: NodeElement) => void;
}

const modActivation: IMutationModActivation = {
  name: 'MOD_ACTIVATION',
  callback(network: Network) {
    // Has no effect on input node, so they are excluded
    if (!this.mutateOutput && network.input + network.output === network.nodes.length) {
      if (config.warnings) console.warn('No nodes that allow mutation of activation function');
      return;
    }

    let index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);
    const node = network.nodes[index];

    this.mutateNode(node);
  },
  mutateNode(node: NodeElement) {
    node.squash = this.allowed[(this.allowed.indexOf(node.squash) + Math.floor(Math.random() * (this.allowed.length - 1)) + 1) % this.allowed.length];
  },
  mutateOutput: true,
  allowed: [
    activation.LOGISTIC,
    activation.TANH,
    activation.RELU,
    activation.IDENTITY,
    activation.STEP,
    activation.SOFTSIGN,
    activation.SINUSOID,
    activation.GAUSSIAN,
    activation.BENT_IDENTITY,
    activation.BIPOLAR,
    activation.BIPOLAR_SIGMOID,
    activation.HARD_TANH,
    activation.ABSOLUTE,
    activation.INVERSE,
    activation.SELU
  ]
};

export default modActivation;
//File content ./src/methods/mutation/sub-gate.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

const subGate: IMutation = {
  name: 'SUB_GATE',
  callback(network: Network) {
    // Select a random gated connection
    if (network.gates.length === 0) {
      if (config.warnings) console.warn('No more connections to ungate!');
      return
    }

    let index = Math.floor(Math.random() * network.gates.length);
    let gatedconn = network.gates[index];

    network.ungate(gatedconn);
  }
};

export default subGate;
//File content ./src/methods/mutation/add-gate.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";
import Connection from "../../architecture/connection";

const addGate: IMutation = {
  name: 'ADD_GATE',
  callback(network: Network) {
    let allconnections = network.connections.concat(network.selfconns);

    // Create a list of all non-gated connections
    let possible: Connection[] = [];
    for (let i = 0; i < allconnections.length; i++) {
      let conn = allconnections[i];
      if (conn.gater === null) {
        possible.push(conn);
      }
    }

    if (possible.length === 0) {
      if (config.warnings) console.warn('No more connections to gate!');
      return
    }

    // Select a random gater node and connection, can't be gated by input
    let index = Math.floor(Math.random() * (network.nodes.length - network.input) + network.input);
    const node = network.nodes[index];
    let conn = possible[Math.floor(Math.random() * possible.length)];

    // Gate the connection with the node
    network.gate(node, conn);
  }
};

export default addGate;
//File content ./src/methods/mutation/mod-bias.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import NodeElement from "../../architecture/node";

export interface IMutationModBias extends IMutation {
  min: number;
  max: number;
  mutateNode: (node: NodeElement) => void;
}

const modBias: IMutationModBias = {
  name: 'MOD_BIAS',
  callback(network: Network) {
    // Has no effect on input node, so they are excluded
    let index = Math.floor(Math.random() * (network.nodes.length - network.input) + network.input);
    const node: NodeElement = network.nodes[index];
    this.mutateNode(node);
  },
  mutateNode(node: NodeElement) {
    let modification = Math.random() * (this.max - this.min) + this.min;
    node.bias += modification;
  },
  min: -1,
  max: 1,
};

export default modBias;
//File content ./src/methods/mutation/mod-weight.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";

interface IMutationModWeight extends IMutation {
  min: number;
  max: number;
}

const modWeight: IMutationModWeight = {
  name: 'MOD_WEIGHT',
  callback(network: Network) {
    let allconnections = network.connections.concat(network.selfconns);

    let connection = allconnections[Math.floor(Math.random() * allconnections.length)];

    if (!connection) {
      return;
    }

    let modification: number = Math.random() * (this.max - this.min) + this.min;
    connection.weight += modification;
  },
  min: -1,
  max: 1
};

export default modWeight;
//File content ./src/methods/mutation/index.ts
import Network from "../../architecture/network";
import addNode from "./add-node";
import subNode from "./sub-node";
import addConn from "./add-conn";
import subConn from "./sub-conn";
import modWeight from "./mod-weight";
import modBias from "./mod-bias";
import modActivation from "./mod-activation";
import addGate from "./add-gate";
import subGate from "./sub-gate";
import addSelfConn from "./add-self-conn";
import subSelfConn from "./sub-self-conn";
import addBackConn from "./add-back-conn";
import subBackConn from "./sub-back-conn";
import swapNodes from "./swap-nodes";

export interface IMutation {
  name: string;
  callback: (network: Network) => void;
}

type IMutationCollection = {[key: string]: IMutation[]};

const mutations: IMutationCollection = {
  ALL: [
    addNode,
    subNode,
    addConn,
    subConn,
    modWeight,
    modBias,
    modActivation,
    addGate,
    subGate,
    addSelfConn,
    subSelfConn,
    addBackConn,
    subBackConn,
    swapNodes
  ],
  FFW: [
    addNode,
    subNode,
    addConn,
    subConn,
    modWeight,
    modBias,
    modActivation,
    swapNodes
  ]
}

export default mutations;
//File content ./src/methods/mutation/swap-nodes.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";

interface IMutationSwapNodes extends IMutation {
  mutateOutput: boolean;
}

const swapNodes: IMutationSwapNodes = {
  name: 'SWAP_NODES',
  callback(network: Network) {
    // Has no effect on input node, so they are excluded
    if ((this.mutateOutput && network.nodes.length - network.input < 2) ||
      (!this.mutateOutput && network.nodes.length - network.input - network.output < 2)) {
      if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');
      return
    }

    let index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);
    let node1 = network.nodes[index];
    index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);
    let node2 = network.nodes[index];

    let biasTemp = node1.bias;
    let squashTemp = node1.squash;

    node1.bias = node2.bias;
    node1.squash = node2.squash;
    node2.bias = biasTemp;
    node2.squash = squashTemp;
  },
  mutateOutput: true
};

export default swapNodes;
//File content ./src/methods/mutation/sub-back-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";
import Connection from "../../architecture/connection";

const subBackConn: IMutation = {
  name: 'SUB_BACK_CONN',
  callback(network: Network) {
    // List of possible connections that can be removed
    let possible: Connection[] = [];

    for (let i = 0; i < network.connections.length; i++) {
      let conn = network.connections[i];
      // Check if it is not disabling a node
      if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && network.nodes.indexOf(conn.from) > network.nodes.indexOf(conn.to)) {
        possible.push(conn);
      }
    }

    if (possible.length === 0) {
      if (config.warnings) console.warn('No connections to remove!');
      return
    }

    let randomConn = possible[Math.floor(Math.random() * possible.length)];
    network.disconnect(randomConn.from, randomConn.to);
  }
};

export default subBackConn;
//File content ./src/methods/mutation/add-self-conn.ts
import {IMutation} from "./index";
import Network from "../../architecture/network";
import config from "../../config";
import NodeElement from "../../architecture/node";

const addSelfConn: IMutation = {
  name: 'ADD_SELF_CONN',
  callback(network: Network) {
    // Check which nodes aren't selfconnected yet
    let possible: NodeElement[] = [];
    for (let i = network.input; i < network.nodes.length; i++) {
      let node = network.nodes[i];
      if (node.connections.self.weight === 0) {
        possible.push(node);
      }
    }

    if (possible.length === 0) {
      if (config.warnings) console.warn('No more self-connections to add!');
      return;
    }

    // Select a random node
    const node = possible[Math.floor(Math.random() * possible.length)];

    // Connect it to himself
    network.connect(node, node);
  }
};

export default addSelfConn;
//File content ./src/methods/crossover.ts
import {ICommonCollection} from "../types/common-collection";

export interface ICrossover {
  name: string;
  config?: number[];
}
type ICrossoverCollection = ICommonCollection<ICrossover>;

// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)
const crossover: ICrossoverCollection = {
  SINGLE_POINT: {
    name: 'SINGLE_POINT',
    config: [0.4]
  },
  TWO_POINT: {
    name: 'TWO_POINT',
    config: [0.4, 0.9]
  },
  UNIFORM: {
    name: 'UNIFORM'
  },
  AVERAGE: {
    name: 'AVERAGE'
  }
};

export default crossover;
//File content ./src/methods/activation.ts
// https://en.wikipedia.org/wiki/Activation_function
// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons
import {IActivationCollection} from "../types/activation-types";

const activation: IActivationCollection = {
  LOGISTIC: (x, derivate) => {
    const fx = 1 / (1 + Math.exp(-x));
    if (!derivate) return fx;
    return fx * (1 - fx);
  },
  TANH: function (x, derivate) {
    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);
    return Math.tanh(x);
  },
  IDENTITY: function (x, derivate) {
    return derivate ? 1 : x;
  },
  STEP: function (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : 0;
  },
  RELU: function (x, derivate) {
    if (derivate) return x > 0 ? 1 : 0;
    return x > 0 ? x : 0;
  },
  SOFTSIGN: function (x, derivate) {
    const d = 1 + Math.abs(x);
    if (derivate) return x / Math.pow(d, 2);
    return x / d;
  },
  SINUSOID: function (x, derivate) {
    if (derivate) return Math.cos(x);
    return Math.sin(x);
  },
  GAUSSIAN: function (x, derivate) {
    const d = Math.exp(-Math.pow(x, 2));
    if (derivate) return -2 * x * d;
    return d;
  },
  BENT_IDENTITY: function (x, derivate) {
    const d = Math.sqrt(Math.pow(x, 2) + 1);
    if (derivate) return x / (2 * d) + 1;
    return (d - 1) / 2 + x;
  },
  BIPOLAR: function (x, derivate) {
    return derivate ? 0 : x > 0 ? 1 : -1;
  },
  BIPOLAR_SIGMOID: function (x, derivate) {
    const d = 2 / (1 + Math.exp(-x)) - 1;
    if (derivate) return 1 / 2 * (1 + d) * (1 - d);
    return d;
  },
  HARD_TANH: function (x, derivate) {
    if (derivate) return x > -1 && x < 1 ? 1 : 0;
    return Math.max(-1, Math.min(1, x));
  },
  ABSOLUTE: function (x, derivate) {
    if (derivate) return x < 0 ? -1 : 1;
    return Math.abs(x);
  },
  INVERSE: function (x, derivate) {
    if (derivate) return -1;
    return 1 - x;
  },
  // https://arxiv.org/pdf/1706.02515.pdf
  SELU: function (x, derivate) {
    const alpha = 1.6732632423543772848170429916717;
    const scale = 1.0507009873554804934193349852946;
    const fx = x > 0 ? x : alpha * Math.exp(x) - alpha;
    if (derivate) {
      return x > 0 ? scale : (fx + alpha) * scale;
    }
    return fx * scale;
  }
};

export default activation;
//File content ./src/methods/connection.ts
// Specifies in what manner two groups are connected
import {IConncetionCollection} from "../types/methods-collection-types";

const connection: IConncetionCollection = {
  ALL_TO_ALL: {
    name: 'OUTPUT'
  },
  ALL_TO_ELSE: {
    name: 'INPUT'
  },
  ONE_TO_ONE: {
    name: 'SELF'
  }
};

export default  connection;
//File content ./src/methods/rate.ts
import {ICommonCollection} from "../types/common-collection";

export type IRateFunction = (baseRate: number, iteration: number) => number;
type IRateFunctionBuilder = () => IRateFunction;
type IRateCollection = ICommonCollection<IRateFunctionBuilder>

// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244
const rate: IRateCollection = {
  FIXED: () => {
    const func: IRateFunction = function (baseRate) { return baseRate; };
    return func;
  },
  STEP: (gamma = 0.9, stepSize = 100) => {
    const func: IRateFunction = (baseRate, iteration) => {
      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));
    };

    return func;
  },
  EXP: (gamma = 0.999) => {
    const func: IRateFunction = (baseRate, iteration) => {
      return baseRate * Math.pow(gamma, iteration);
    };

    return func;
  },
  INV: (gamma = 0.001, power = 2) => {
    const func: IRateFunction = function (baseRate, iteration) {
      return baseRate * Math.pow(1 + gamma * iteration, -power);
    };

    return func;
  }
};

export default  rate;
//File content ./src/methods/gating.ts
import {IGateCollection} from '../types/methods-gating-types';

// Specifies how to gate a connection between two groups of multiple neurons
const gating: IGateCollection = {
  OUTPUT: {
    name: 'OUTPUT'
  },
  INPUT: {
    name: 'INPUT'
  },
  SELF: {
    name: 'SELF'
  }
};

export default gating;
//File content ./src/methods/methods.ts
import activation from './activation';
import mutation from './mutation';
import selection from "./selection";
import crossover from "./crossover";
import cost from './cost';
import gating from './gating';
import connection from "./connection";
import rate from './rate';

export default {
  activation,
  mutation,
  selection,
  crossover,
  cost,
  gating,
  connection,
  rate
};
//File content ./src/multithreading/multi.ts
import workers from "./workers/workers";

export { workers };

export function serializeDataSet(
  dataSet: { input: number[]; output: number[] }[]
) {
  var serialized = [dataSet[0].input.length, dataSet[0].output.length];

  for (var i = 0; i < dataSet.length; i++) {
    var j;
    for (j = 0; j < serialized[0]; j++) {
      serialized.push(dataSet[i].input[j]);
    }
    for (j = 0; j < serialized[1]; j++) {
      serialized.push(dataSet[i].output[j]);
    }
  }

  return serialized;
}

/**
 * Activate a serialized network
 * @todo: выкосить типы any
 */
export function activateSerializedNetwork(
  input: any,
  A: any,
  S: any,
  data: any,
  F: any
) {
  for (var i = 0; i < data[0]; i++) {
    A[i] = input[i];
  }
  for (i = 2; i < data.length; i++) {
    let index = data[i++];
    let bias = data[i++];
    let squash = data[i++];
    let selfweight = data[i++];
    let selfgater = data[i++];

    S[index] =
      (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;

    while (data[i] !== -2) {
      S[index] +=
        A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);
    }
    A[index] = F[squash](S[index]);
  }

  var output = [];
  for (i = A.length - data[1]; i < A.length; i++) output.push(A[i]);
  return output;
}

/** Deserializes a dataset to an array of arrays */
export function deserializeDataSet(serializedSet: number[]) {
  var set = [];

  var sampleSize = serializedSet[0] + serializedSet[1];
  for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {
    let input = [];
    for (
      var j = 2 + i * sampleSize;
      j < 2 + i * sampleSize + serializedSet[0];
      j++
    ) {
      input.push(serializedSet[j]);
    }
    let output = [];
    for (
      j = 2 + i * sampleSize + serializedSet[0];
      j < 2 + i * sampleSize + sampleSize;
      j++
    ) {
      output.push(serializedSet[j]);
    }
    set.push(input);
    set.push(output);
  }

  return set;
}

/** A list of compiled activation functions in a certain order */
export const activations = [
  function (x: number) {
    return 1 / (1 + Math.exp(-x));
  },
  function (x: number) {
    return Math.tanh(x);
  },
  function (x: number) {
    return x;
  },
  function (x: number) {
    return x > 0 ? 1 : 0;
  },
  function (x: number) {
    return x > 0 ? x : 0;
  },
  function (x: number) {
    return x / (1 + Math.abs(x));
  },
  function (x: number) {
    return Math.sin(x);
  },
  function (x: number) {
    return Math.exp(-Math.pow(x, 2));
  },
  function (x: number) {
    return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x;
  },
  function (x: number) {
    return x > 0 ? 1 : -1;
  },
  function (x: number) {
    return 2 / (1 + Math.exp(-x)) - 1;
  },
  function (x: number) {
    return Math.max(-1, Math.min(1, x));
  },
  function (x: number) {
    return Math.abs(x);
  },
  function (x: number) {
    return 1 - x;
  },
  function (x: number) {
    var a = 1.6732632423543772848170429916717;
    return (
      (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946
    );
  },
];

export function testSerializedSet(
  set: any,
  cost: any,
  A: any,
  S: any,
  data: any,
  F: any
) {
  // Calculate how much samples are in the set
  var error = 0;
  for (var i = 0; i < set.length; i += 2) {
    let output = activateSerializedNetwork(set[i], A, S, data, F);
    error += cost(set[i + 1], output);
  }

  return error / (set.length / 2);
}
//File content ./src/multithreading/workers/workers.ts
import NodeTestWorker from './node/testworker';
import BrowserTestWorker from './browser/testworker';
import {INetworkTrainingSetItem} from "../../architecture/network";

export enum EWokerMessageType {
  init = 'init',
  iteration = 'iteration',
}

export interface IWorkerInitMessage extends IWorkerMessage {
  dataSet: INetworkTrainingSetItem[];
  cost: string;
}

export interface IWorkerIterationMessage extends IWorkerMessage {
  network: any;
}

export interface IWorkerMessage {
  type: EWokerMessageType;
}

const workers = {
  node: {
    TestWorker: NodeTestWorker
  },
  browser: {
    TestWorker: BrowserTestWorker
  }
};

export default workers;
//File content ./src/multithreading/workers/browser/testworker.ts
import Network, {INetworkTrainingSetItem} from "../../../architecture/network";
import {EWokerMessageType, IWorkerInitMessage, IWorkerIterationMessage} from "../workers";

/*******************************************************************************
 WEBWORKER
 *******************************************************************************/

export default class BrowserTestWorker {
  url: string;
  worker: Worker;

  constructor(workerUrl: string, dataSet: INetworkTrainingSetItem[], cost: any) {
    this.url = workerUrl;
    this.worker = new Worker(this.url);

    const msgPayload: IWorkerInitMessage = {
      type: EWokerMessageType.init,
      dataSet: dataSet,
      cost: cost.name
    };

    this.worker.postMessage(msgPayload);
  }

  evaluate(network: Network): Promise<any> {
    return new Promise((resolve) => {
      const msgPayload: IWorkerIterationMessage = {
        type: EWokerMessageType.iteration,
        network: network.toJSON()
      };

      this.worker.onmessage = function (e) {
        var error = new Float64Array(e.data.buffer)[0];
        resolve(error);
      };

      this.worker.postMessage(msgPayload);
    });
  }

  terminate () {
    this.worker.terminate();
    window.URL.revokeObjectURL(this.url);
  }
}
//File content ./src/multithreading/workers/browser/_ols_testworker.ts
import Network from "../../../architecture/network";
import * as multi from '../../multi';

/*******************************************************************************
                                WEBWORKER
*******************************************************************************/

export default class BrowserTestWorker {
  url: string;
  worker: Worker;

  constructor(dataSet: any, cost: any) {
    var blob = new Blob([this._createBlobString(cost)]);
    this.url = window.URL.createObjectURL(blob);
    this.worker = new Worker(this.url);

    var data = { set: new Float64Array(dataSet).buffer };
    this.worker.postMessage(data, [data.set]);
  }

  evaluate(network: Network): Promise<any> {
    return new Promise((resolve) => {
      var serialized = network.serialize();

      var data = {
        activations: new Float64Array(serialized[0]).buffer,
        states: new Float64Array(serialized[1]).buffer,
        conns: new Float64Array(serialized[2]).buffer,
      };

      this.worker.onmessage = function (e) {
        var error = new Float64Array(e.data.buffer)[0];
        resolve(error);
      };

      this.worker.postMessage(data, [
        data.activations,
        data.states,
        data.conns,
      ]);
    });
  }

  terminate () {
    this.worker.terminate();
    window.URL.revokeObjectURL(this.url);
  }

  protected _createBlobString(cost: string) {
    return `
      var F = [${multi.activations.toString()}];
      var cost = ${cost.toString()};
      
      const deserializeDataSet = ${multi.deserializeDataSet.toString()};
      const testSerializedSet = ${multi.testSerializedSet.toString()};
      const activateSerializedNetwork = ${multi.activateSerializedNetwork.toString()};
      
      var multi = {
        deserializeDataSet,
        testSerializedSet,
        activateSerializedNetwork
      };

      this.onmessage = function (e) {
        if(typeof e.data.set === 'undefined'){
          var A = new Float64Array(e.data.activations);
          var S = new Float64Array(e.data.states);
          var data = new Float64Array(e.data.conns);

          var error = multi.testSerializedSet(set, cost, A, S, data, F);

          var answer = { buffer: new Float64Array([error ]).buffer };
          postMessage(answer, [answer.buffer]);
        } else {
          set = multi.deserializeDataSet(new Float64Array(e.data.set));
        }
      };`;
  }
}
//File content ./src/multithreading/workers/browser/worker.ts
import {ICostFunction} from '../../../methods/cost';
import {EWokerMessageType, IWorkerInitMessage, IWorkerIterationMessage, IWorkerMessage} from "../workers";
import Network, {INetworkTrainingSetItem} from "../../../architecture/network";
import methods from "../../../methods/methods";

var set: INetworkTrainingSetItem[] = [];
var cost: ICostFunction;

interface IDefaultWorkerMessage<T> {
  data: T
}

(globalThis as any).onmessage = (e: IDefaultWorkerMessage<IWorkerMessage>) => {
  const msg = e.data;

  if (msg.type === EWokerMessageType.init) {
    const initMessage = msg as IWorkerInitMessage;

    set = initMessage.dataSet;
    cost = methods.cost[initMessage.cost];
  } else if (msg.type === EWokerMessageType.iteration) {
    const iterationMessage = msg as IWorkerIterationMessage;

    const network = Network.fromJSON(iterationMessage.network);

    const error = network.test(set, cost).error;

    const answer = { buffer: new Float64Array([error ]).buffer };

    //@ts-ignore
    postMessage(answer, [answer.buffer]);
  }
};
//File content ./src/multithreading/workers/node/testworker.ts
import cp from 'child_process';
import path from 'path';
import Network, {INetworkTrainingSetItem} from '../../../architecture/network';
import {ICostFunction} from "../../../methods/cost";
import {EWokerMessageType, IWorkerInitMessage, IWorkerIterationMessage} from "../workers";

export default class NodeTestWorker {
  public worker: cp.ChildProcess;

  // @todo: выкосить any
  constructor(dataSet: INetworkTrainingSetItem[], cost: ICostFunction) {
    if (typeof require !== 'undefined' && '.ts' in eval('require.extensions')) {
      this.worker = cp.fork(path.join(__dirname, '/worker.ts'), [], { execArgv: ['-r', 'ts-node/register'] });
    } else {
      this.worker = cp.fork(path.join(process.env.PWD as string, './dist/worker.js'));
    }

    const msgPayload: IWorkerInitMessage = {
      type: EWokerMessageType.init,
      dataSet: dataSet,
      cost: cost.name
    };

    this.worker.send(msgPayload);
  }

  evaluate(network: Network): Promise<any> {
    return new Promise((resolve) => {
      const msgPayload: IWorkerIterationMessage = {
        type: EWokerMessageType.iteration,
        network: network.toJSON()
      };

      var _that = this.worker;
      this.worker.on('message', function callback(e) {
        _that.removeListener('message', callback);
        resolve(e);
      });

      this.worker.send(msgPayload);
    });
  }

  terminate() {
    this.worker.kill();
  }
}
//File content ./src/multithreading/workers/node/worker.ts
import {ICostFunction} from '../../../methods/cost';
import {EWokerMessageType, IWorkerInitMessage, IWorkerIterationMessage, IWorkerMessage} from "../workers";
import Network, {INetworkTrainingSetItem} from "../../../architecture/network";
import methods from "../../../methods/methods";
import {ChildProcess} from "node:child_process";

var set: INetworkTrainingSetItem[] = [];
var cost: ICostFunction;

process.on('message', (e: IWorkerMessage) => {
  if (e.type === EWokerMessageType.init) {
    const initMessage = e as IWorkerInitMessage;

    set = initMessage.dataSet;
    cost = methods.cost[initMessage.cost];
  } else if (e.type === EWokerMessageType.iteration) {
    const iterationMessage = e as IWorkerIterationMessage;

    const network = Network.fromJSON(iterationMessage.network);

    const error = network.test(set, cost).error;

    (process as unknown as ChildProcess).send(error);
  }
});
//File content ./src/architecture/node.ts
import {IActivationFunction} from "../types/activation-types";

import Connection from './connection';
import Group from './group';

import methods from '../methods/methods';
import config from '../config';
import {NodeTypeEnum} from "../types/node-type-enum";

type NodeConnectionsDescriptor = {
  in: Connection[];
  out: Connection[];
  gated: Connection[];
  self: Connection;
};

type NodeErrorDescriptor = {
  responsibility: number,
  projected: number,
  gated: number
};

export default class NodeElement {
  public bias: number;
  public squash: IActivationFunction;
  public type: NodeTypeEnum;

  public activation: number = 0;
  public derivative: number = 0;
  public state: number = 0;
  public old: number = 0;

  public mask: number = 1;

  // For tracking momentum
  public previousDeltaBias: number = 0;

  // Batch training
  public totalDeltaBias: number = 0;

  public connections: NodeConnectionsDescriptor;

  public error: NodeErrorDescriptor = {
    responsibility: 0,
    projected: 0,
    gated: 0
  };

  constructor(nodeType?: NodeTypeEnum) {
    this.bias = (nodeType === NodeTypeEnum.input) ? 0 : Math.random() * 0.2 - 0.1;
    this.squash = methods.activation.LOGISTIC;
    this.type = nodeType || NodeTypeEnum.hidden;

    this.connections = {
      in: [],
      out: [],
      gated: [],
      self: new Connection(this, this, 0)
    };
  }

  /**
   * Activates the node
   */
  activate(input?: number): number {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    this.old = this.state;

    // All activation sources coming from the node itself
    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    for (let i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      this.state += connection.from.activation * connection.weight * connection.gain;
    }

    // Squash the values received
    this.activation = this.squash(this.state) * this.mask;
    this.derivative = this.squash(this.state, true);

    // Update traces
    var nodes = [];
    var influences = [];

    for (let i = 0; i < this.connections.gated.length; i++) {
      let conn = this.connections.gated[i];
      let node = conn.to;

      let index = nodes.indexOf(node);
      if (index > -1) {
        influences[index] += conn.weight * conn.from.activation;
      } else {
        nodes.push(node);
        influences.push(conn.weight * conn.from.activation +
          (node.connections.self.gater === this ? node.old : 0));
      }

      // Adjust the gain to this nodes' activation
      conn.gain = this.activation;
    }

    for (let i = 0; i < this.connections.in.length; i++) {
      let connection = this.connections.in[i];

      // Elegibility trace
      connection.elegibility = this.connections.self.gain * this.connections.self.weight *
        connection.elegibility + connection.from.activation * connection.gain;

      // Extended trace
      for (var j = 0; j < nodes.length; j++) {
        let node = nodes[j];
        let influence = influences[j];

        let index = connection.xtrace.nodes.indexOf(node);

        if (index > -1) {
          connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *
            connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;
        } else {
          // Does not exist there yet, might be through mutation
          connection.xtrace.nodes.push(node);
          connection.xtrace.values.push(this.derivative * connection.elegibility * influence);
        }
      }
    }

    return this.activation;
  }

  /**
   * Activates the node without calculating elegibility traces and such
   */
  noTraceActivate (input?: number): number {
    // Check if an input is given
    if (typeof input !== 'undefined') {
      this.activation = input;
      return this.activation;
    }

    // All activation sources coming from the node itself
    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;

    // Activation sources coming from connections
    var i;
    for (i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];
      this.state += connection.from.activation * connection.weight * connection.gain;
    }

    // Squash the values received
    this.activation = this.squash(this.state);

    for (i = 0; i < this.connections.gated.length; i++) {
      this.connections.gated[i].gain = this.activation;
    }

    return this.activation;
  }

  /**
   * Back-propagate the error, aka learn
   */
  propagate (rate: number = 0.3, momentum: number = 0, update: boolean, target?: number) {
//    momentum = momentum || 0;
//    rate = rate || 0.3;

    // Error accumulator
    let error = 0;

    // Output nodes get their error from the enviroment
    if (this.type === NodeTypeEnum.output) {
      this.error.responsibility = this.error.projected = (target || 0) - this.activation;
    } else { // the rest of the nodes compute their error responsibilities by backpropagation
      // error responsibilities from all the connections projected from this node
      for (let i = 0; i < this.connections.out.length; i++) {
        let connection = this.connections.out[i];
        let node = connection.to;
        // Eq. 21
        error += node.error.responsibility * connection.weight * connection.gain;
      }

      // Projected error responsibility
      this.error.projected = this.derivative * error;

      // Error responsibilities from all connections gated by this neuron
      error = 0;

      for (let i = 0; i < this.connections.gated.length; i++) {
        let conn = this.connections.gated[i];
        let node = conn.to;
        let influence = node.connections.self.gater === this ? node.old : 0;

        influence += conn.weight * conn.from.activation;
        error += node.error.responsibility * influence;
      }

      // Gated error responsibility
      this.error.gated = this.derivative * error;

      // Error responsibility
      this.error.responsibility = this.error.projected + this.error.gated;
    }

    if (this.type === NodeTypeEnum.constant) return;

    // Adjust all the node's incoming connections
    for (let i = 0; i < this.connections.in.length; i++) {
      let connection = this.connections.in[i];

      let gradient = this.error.projected * connection.elegibility;

      for (var j = 0; j < connection.xtrace.nodes.length; j++) {
        let node = connection.xtrace.nodes[j];
        let value = connection.xtrace.values[j];
        gradient += node.error.responsibility * value;
      }

      // Adjust weight
      let deltaWeight = rate * gradient * this.mask;
      connection.totalDeltaWeight += deltaWeight;
      if (update) {
        connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;
        connection.weight += connection.totalDeltaWeight;
        connection.previousDeltaWeight = connection.totalDeltaWeight;
        connection.totalDeltaWeight = 0;
      }
    }

    // Adjust bias
    const deltaBias = rate * this.error.responsibility;
    this.totalDeltaBias += deltaBias;
    if (update) {
      this.totalDeltaBias += momentum * this.previousDeltaBias;
      this.bias += this.totalDeltaBias;
      this.previousDeltaBias = this.totalDeltaBias;
      this.totalDeltaBias = 0;
    }
  }

  /**
   * Creates a connection from this node to the given node
   */
  connect(target: NodeElement | Group, weight?: number): Connection[] {
    const connections: Connection[] = [];
    if (typeof (target as any).bias !== 'undefined') { // must be a node!
      target = target as NodeElement;
      if (target === this) {
        // Turn on the self connection by setting the weight
        if (this.connections.self.weight !== 0) {
          if (config.warnings) console.warn('This connection already exists!');
        } else {
          this.connections.self.weight = weight || 1;
        }
        connections.push(this.connections.self);
      } else if (this.isProjectingTo(target)) {
        throw new Error('Already projecting a connection to this node!');
      } else {
        let connection = new Connection(this, target, weight);
        target.connections.in.push(connection);
        this.connections.out.push(connection);

        connections.push(connection);
      }
    } else { // should be a group
      target = target as Group;
      for (var i = 0; i < target.nodes.length; i++) {
        let connection = new Connection(this, target.nodes[i], weight);
        target.nodes[i].connections.in.push(connection);
        this.connections.out.push(connection);
        target.connections.in.push(connection);

        connections.push(connection);
      }
    }
    return connections;
  }

  /**
   * Disconnects this node from the other node
   */
  disconnect (node: NodeElement, twosided?: boolean) {
    if (this === node) {
      this.connections.self.weight = 0;
      return;
    }

    for (let i = 0; i < this.connections.out.length; i++) {
      let conn = this.connections.out[i];
      if (conn.to === node) {
        this.connections.out.splice(i, 1);
        let j = conn.to.connections.in.indexOf(conn);
        conn.to.connections.in.splice(j, 1);
        if (conn.gater !== null) conn.gater.ungate(conn);
        break;
      }
    }

    if (twosided) {
      node.disconnect(this);
    }
  }

  /**
   * Make this node gate a connection
   */
  gate(connections: Connection | Connection[]) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (let i = 0; i < connections.length; i++) {
      let connection = connections[i];

      this.connections.gated.push(connection);
      connection.gater = this;
    }
  }

  /**
   * Removes the gates from this node from the given connection(s)
   */
  ungate (connections: Connection | Connection[]) {
    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    for (var i = connections.length - 1; i >= 0; i--) {
      var connection = connections[i];

      var index = this.connections.gated.indexOf(connection);
      this.connections.gated.splice(index, 1);
      connection.gater = null;
      connection.gain = 1;
    }
  }

  /**
   * Clear the context of the node
   */
  clear () {
    for (var i = 0; i < this.connections.in.length; i++) {
      var connection = this.connections.in[i];

      connection.elegibility = 0;
      connection.xtrace = {
        nodes: [],
        values: []
      };
    }

    for (i = 0; i < this.connections.gated.length; i++) {
      let conn = this.connections.gated[i];
      conn.gain = 0;
    }

    this.error.responsibility = this.error.projected = this.error.gated = 0;
    this.old = this.state = this.activation = 0;
  }

  /**
   * Checks if this node is projecting to the given node
   */
  isProjectingTo(node: NodeElement) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.out.length; i++) {
      var conn = this.connections.out[i];
      if (conn.to === node) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if the given node is projecting to this node
   */
  isProjectedBy(node: NodeElement) {
    if (node === this && this.connections.self.weight !== 0) return true;

    for (var i = 0; i < this.connections.in.length; i++) {
      var conn = this.connections.in[i];
      if (conn.from === node) {
        return true;
      }
    }

    return false;
  }

  /**
   * Converts the node to a json object
   */
  toJSON() {
    return {
      bias: this.bias,
      type: this.type,
      squash: this.squash.name,
      mask: this.mask
    };
  }

  /**
   * @todo: Удалить тип any или сделать валидацию
   */
  static fromJSON(json: any): NodeElement {
    var node = new NodeElement();
    node.bias = json.bias;
    node.type = json.type;
    node.mask = json.mask;
    node.squash = methods.activation[json.squash];

    return node;
  }
}
//File content ./src/architecture/network.ts
import {ICostFunction} from "../methods/cost";
import {IMutation} from "../methods/mutation";
import {IActivationFunction} from "../types/activation-types";
import Connection from "./connection";
import NodeElement from "./node";

/* Import */
import * as multi from '../multithreading/multi';
import methods from '../methods/methods';
import config from '../config';
import Neat, {IFitnessFunction} from '../helpers/neat';
import BrowserTestWorker from "../multithreading/workers/browser/testworker";
import NodeTestWorker from "../multithreading/workers/node/testworker";
import {NodeTypeEnum} from "../types/node-type-enum";
import {IRateFunction} from "../methods/rate";
import subNode from "../methods/mutation/sub-node";

export type INetworkTrainingSetItem = { input: number[], output: number[] };

export type INetworkTrainingOptions = {
  error?: number;
  rate?: number;
  dropout?: number;
  momentum?: number;
  batchSize?: number;
  cost?: ICostFunction;
  iterations?: number;
  browserWorkerScriptUrl?: string;
  popsize?: number;

  mutation?: IMutation[];
  equal?: boolean;
  elitism?: number;
  mutationRate?: number;
  mutationAmount?: number;

  ratePolicy?: IRateFunction;

  crossValidate?: {
    testSize: number;
    testError: number;
  };

  clear?: boolean;
  shuffle?: boolean;

  log?: number;

  schedule?: {
    iterations: number;
    function: (x: { error: number, iteration: number, fitness?: number }) => void;
  };

  growth?: number;
  amount?: number;
  threads?: number;

  fitnessPopulation?: boolean;

  network?: Network;

  callback?: (n: Network, result: { error: number, iteration: number, fitness?: number }) => void;
};

export default class Network {
  public nodes: NodeElement[];
  public connections: Connection[];
  public input: number;
  public output: number;
  public dropout: number;
  public gates: Connection[];
  public selfconns: Connection[];

  public score?: number;

  protected isEvolvingStopped: boolean;
  protected evolvingPromise?: Promise<{error: number, iterations: number, time: number}>;

  constructor(input: number, output: number) {
    if (typeof input === 'undefined' || typeof output === 'undefined') {
      throw new Error('No input or output size given');
    }

    this.input = input;
    this.output = output;

    // Store all the node and connection genes
    this.nodes = []; // Stored in activation order
    this.connections = [];
    this.gates = [];
    this.selfconns = [];

    this.isEvolvingStopped = false;

    // Regularization
    this.dropout = 0;

    // Create input and output nodes
    for (let i = 0; i < this.input + this.output; i++) {
      var type = i < this.input ? NodeTypeEnum.input : NodeTypeEnum.output;
      this.nodes.push(new NodeElement(type));
    }

    // Connect input nodes with output nodes directly
    for (let i = 0; i < this.input; i++) {
      for (var j = this.input; j < this.output + this.input; j++) {
        // https://stats.stackexchange.com/a/248040/147931
        var weight = Math.random() * this.input * Math.sqrt(2 / this.input);
        this.connect(this.nodes[i], this.nodes[j], weight);
      }
    }
  }

  /**
   * Activates the network
   */
  activate(input: number[], training?: boolean) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === NodeTypeEnum.input) {
        this.nodes[i].activate(input[i]);
      } else if (this.nodes[i].type === NodeTypeEnum.output) {
        var activation = this.nodes[i].activate();
        output.push(activation);
      } else {
        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;
        this.nodes[i].activate();
      }
    }

    return output;
  }

  /**
   * Activates the network without calculating elegibility traces and such
   */
  noTraceActivate(input: number[]) {
    var output = [];

    // Activate nodes chronologically
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].type === NodeTypeEnum.input) {
        this.nodes[i].noTraceActivate(input[i]);
      } else if (this.nodes[i].type === NodeTypeEnum.output) {
        var activation = this.nodes[i].noTraceActivate();
        output.push(activation);
      } else {
        this.nodes[i].noTraceActivate();
      }
    }

    return output;
  }

  /**
   * Backpropagate the network
   */
  propagate(rate: number, momentum: number, update: boolean, target: number[]) {
    if (typeof target === 'undefined' || target.length !== this.output) {
      throw new Error('Output target length should match network output length');
    }

    var targetIndex = target.length;

    // Propagate output nodes
    var i;
    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {
      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);
    }

    // Propagate hidden and input nodes
    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {
      this.nodes[i].propagate(rate, momentum, update);
    }
  }

  /**
   * Clear the context of the network
   */
  clear() {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }

  /**
   * Connects the from node to the to node
   */
  connect(from: NodeElement, to: NodeElement, weight?: number) {
    const connections: Connection[] = from.connect(to, weight);

    for (let i = 0; i < connections.length; i++) {
      const connection: Connection = connections[i];
      if (from !== to) {
        this.connections.push(connection);
      } else {
        this.selfconns.push(connection);
      }
    }

    return connections;
  }

  /**
   * Disconnects the from node from the to node
   */
  disconnect(from: NodeElement, to: NodeElement) {
    // Delete the connection in the network's connection array
    var connections = from === to ? this.selfconns : this.connections;

    for (var i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (connection.from === from && connection.to === to) {
        if (connection.gater !== null) this.ungate(connection);
        connections.splice(i, 1);
        break;
      }
    }

    // Delete the connection at the sending and receiving neuron
    from.disconnect(to);
  }

  /**
   * Gate a connection with a node
   */
  gate(node: NodeElement, connection: Connection) {
    if (this.nodes.indexOf(node) === -1) {
      throw new Error('This node is not part of the network!');
    } else if (connection.gater != null) {
      if (config.warnings) console.warn('This connection is already gated!');
      return;
    }
    node.gate(connection);
    this.gates.push(connection);
  }

  /**
   *  Remove the gate of a connection
   */
  ungate(connection: Connection) {
    var index = this.gates.indexOf(connection);
    if (index === -1) {
      throw new Error('This connection is not gated!');
    }

    this.gates.splice(index, 1);
    connection.gater?.ungate(connection);
  }

  /**
   *  Removes a node from the network
   */
  remove(node: NodeElement) {
    var index = this.nodes.indexOf(node);

    if (index === -1) {
      throw new Error('This node does not exist in the network!');
    }

    // Keep track of gaters
    var gaters = [];

    // Remove selfconnections from this.selfconns
    this.disconnect(node, node);

    // Get all its inputting nodes
    var inputs = [];
    for (var i = node.connections.in.length - 1; i >= 0; i--) {
      let connection = node.connections.in[i];
      if (subNode.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      inputs.push(connection.from);
      this.disconnect(connection.from, node);
    }

    // Get all its outputing nodes
    var outputs = [];
    for (i = node.connections.out.length - 1; i >= 0; i--) {
      let connection = node.connections.out[i];
      if (subNode.keep_gates && connection.gater !== null && connection.gater !== node) {
        gaters.push(connection.gater);
      }
      outputs.push(connection.to);
      this.disconnect(node, connection.to);
    }

    // Connect the input nodes to the output nodes (if not already connected)
    var connections = [];
    for (i = 0; i < inputs.length; i++) {
      let input = inputs[i];
      for (var j = 0; j < outputs.length; j++) {
        let output = outputs[j];
        if (!input.isProjectingTo(output)) {
          var conn = this.connect(input, output);
          connections.push(conn[0]);
        }
      }
    }

    // Gate random connections with gaters
    for (i = 0; i < gaters.length; i++) {
      if (connections.length === 0) break;

      let gater = gaters[i];
      let connIndex = Math.floor(Math.random() * connections.length);

      this.gate(gater, connections[connIndex]);
      connections.splice(connIndex, 1);
    }

    // Remove gated connections gated by this node
    for (i = node.connections.gated.length - 1; i >= 0; i--) {
      let conn = node.connections.gated[i];
      this.ungate(conn);
    }

    // Remove selfconnection
    this.disconnect(node, node);

    // Remove the node from this.nodes
    this.nodes.splice(index, 1);
  }

  /**
   * Mutates the network with the given method
   */
  mutate(method?: IMutation) {
    if (typeof method === 'undefined') {
      throw new Error('No (correct) mutate method given!');
    }

    method.callback(this);
  }

  /**
   * Train the given set to this network
   */
  train(set: INetworkTrainingSetItem[], options: INetworkTrainingOptions = {}) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    // Warning messages
    if (typeof options.rate === 'undefined') {
      if (config.warnings) console.warn('Using default learning rate, please define a rate!');
    }
    if (typeof options.iterations === 'undefined') {
      if (config.warnings) console.warn('No target iterations given, running until error is reached!');
    }

    // Read the options
    var targetError = options.error || 0.05;
    var cost = options.cost || methods.cost.MSE;
    var baseRate = options.rate || 0.3;
    var dropout = options.dropout || 0;
    var momentum = options.momentum || 0;
    var batchSize = options.batchSize || 1; // online learning
    var ratePolicy = options.ratePolicy || methods.rate.FIXED();

    var start = Date.now();

    if (batchSize > set.length) {
      throw new Error('Batch size must be smaller or equal to dataset length!');
    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    // Save to network
    this.dropout = dropout;

    let trainSet: INetworkTrainingSetItem[] = [],
      testSet: INetworkTrainingSetItem[] = [];

    if (options.crossValidate) {
      let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);
      trainSet = set.slice(0, numTrain);
      testSet = set.slice(numTrain);
    }

    // Loops the training process
    var currentRate = baseRate;
    var iteration = 0;
    var error = 1;

    // var i, j, x;
    while (error > targetError && (options.iterations === 0 || iteration < (options.iterations as number))) {
      if (options.crossValidate && error <= options.crossValidate.testError) break;

      iteration++;

      // Update the rate
      currentRate = ratePolicy(baseRate, iteration);

      // Checks if cross validation is enabled
      if (options.crossValidate) {
        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
        error = this.test(testSet, cost).error;
        if (options.clear) this.clear();
      } else {
        error = this._trainSet(set, batchSize, currentRate, momentum, cost);
        if (options.clear) this.clear();
      }

      // Checks for options such as scheduled logs and shuffling
      if (options.shuffle) {

        for (let j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x) ;
      }

      if (options.log && iteration % options.log === 0) {
        console.log('iteration', iteration, 'error', error, 'rate', currentRate);
      }

      if (options.schedule && iteration % options.schedule.iterations === 0) {
        options.schedule.function({error: error, iteration: iteration});
      }
    }

    if (options.clear) this.clear();

    if (dropout) {
      for (let i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === NodeTypeEnum.hidden || this.nodes[i].type === NodeTypeEnum.constant) {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    return {
      error: error,
      iterations: iteration,
      time: Date.now() - start
    };
  }

  /**
   * Performs one training epoch and returns the error
   * private function used in this.train
   */
  _trainSet(set: INetworkTrainingSetItem[], batchSize: number, currentRate: number, momentum: number, costFunction: ICostFunction) {
    let errorSum = 0;
    for (var i = 0; i < set.length; i++) {
      const input = set[i].input;
      const target = set[i].output;

      const update = ((i + 1) % batchSize === 0 || (i + 1) === set.length);

      const output = this.activate(input, true);
      this.propagate(currentRate, momentum, update, target);

      errorSum += costFunction(target, output);
    }
    return errorSum / set.length;
  }

  /**
   * Tests a set and returns the error and elapsed time
   */
  test(set: INetworkTrainingSetItem[], cost = methods.cost.MSE) {
    // Check if dropout is enabled, set correct mask
    var i;
    if (this.dropout) {
      for (i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].type === NodeTypeEnum.hidden || this.nodes[i].type === NodeTypeEnum.constant) {
          this.nodes[i].mask = 1 - this.dropout;
        }
      }
    }

    var error = 0;
    var start = Date.now();

    for (i = 0; i < set.length; i++) {
      let input = set[i].input;
      let target = set[i].output;
      let output = this.noTraceActivate(input);
      error += cost(target, output);
    }

    error /= set.length;

    return {
      error: error,
      time: Date.now() - start
    };
  }

  /**
   * Convert the network to a json object
   */
  toJSON() {
    var json = {
      nodes: [] as any[],
      connections: [] as any[],
      input: this.input,
      output: this.output,
      dropout: this.dropout
    };

    // So we don't have to use expensive .indexOf()
    for (let i = 0; i < this.nodes.length; i++) {
      (this.nodes[i] as any).index = i;
    }

    for (let i = 0; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      let tojson = node.toJSON() as any;
      tojson.index = i;
      json.nodes.push(tojson);

      if (node.connections.self.weight !== 0) {
        let tojson = node.connections.self.toJSON() as any;
        tojson.from = i;
        tojson.to = i;

        tojson.gater = node.connections.self.gater != null ? (node.connections.self.gater as any).index : null;
        json.connections.push(tojson);
      }
    }

    for (let i = 0; i < this.connections.length; i++) {
      let conn = this.connections[i];
      let tojson = conn.toJSON() as any;
      tojson.from = (conn.from as any).index;
      tojson.to = (conn.to as any).index;

      tojson.gater = conn.gater != null ? (conn.gater as any).index : null;

      json.connections.push(tojson);
    }

    return json;
  }

  /**
   * Sets the value of a property for every node in this network
   */
  set(values: { bias?: number; squash?: IActivationFunction }) {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].bias = values.bias || this.nodes[i].bias;
      this.nodes[i].squash = values.squash || this.nodes[i].squash;
    }
  }

  stopEvolve(): Promise<{error: number, iterations: number, time: number}> {
    this.isEvolvingStopped = true;
    return this.evolvingPromise as Promise<{error: number, iterations: number, time: number}>;
  }

  /**
   * Evolves the network to reach a lower error on a dataset
   */
  async evolve(set: INetworkTrainingSetItem[], options: INetworkTrainingOptions) {
    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {
      throw new Error('Dataset input/output size should be same as network input/output size!');
    }

    this.isEvolvingStopped = false;

    let resolveEvolve: any;
    this.evolvingPromise = new Promise((resolve) => {
      resolveEvolve = resolve;
    });

    // Read the options
    options = options || {};
    var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;
    var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;
    var cost = options.cost || methods.cost.MSE;
    var amount = options.amount || 1;

    var threads = options.threads as number;
    if (typeof threads === 'undefined') {
      if (typeof window === 'undefined') { // Node.js
        threads = require('os').cpus().length;
      } else { // Browser
        threads = navigator.hardwareConcurrency;
      }
    }

    var start = Date.now();

    if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {
      throw new Error('At least one of the following options must be specified: error, iterations');
    } else if (typeof options.error === 'undefined') {
      targetError = -1; // run until iterations
    } else if (typeof options.iterations === 'undefined') {
      options.iterations = 0; // run until target error
    }

    var fitnessFunction: IFitnessFunction;
    let workers: (BrowserTestWorker | NodeTestWorker)[] = [];

    if (typeof window !== 'undefined' && options.browserWorkerScriptUrl == undefined) {
      threads = 1;
    }

    if (threads === 1) {
      // Create the fitness function
      fitnessFunction = function (genome: Network) {
        var score = 0;
        for (var i = 0; i < amount; i++) {
          score -= genome.test(set, cost).error;
        }

        score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;
        score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection

        return score / amount;
      } as IFitnessFunction;
    } else {

      // Create workers, send datasets
      workers = [];
      if (typeof window === 'undefined') {
        for (let i = 0; i < threads; i++) {
          workers.push(new multi.workers.node.TestWorker(set, cost));
        }
      } else {
        for (let i = 0; i < threads; i++) {
          workers.push(new multi.workers.browser.TestWorker(options.browserWorkerScriptUrl as string, set, cost));
        }
      }

      fitnessFunction = function (population: Network[]): Promise<undefined> {
        return new Promise((resolve) => {
          // Create a queue
          var queue = population.slice();
          var done = 0;

          // Start worker function
          var startWorker = function (worker: BrowserTestWorker | NodeTestWorker) {
            if (!queue.length) {
              if (++done === threads) resolve(undefined);
              return;
            }

            var genome: Network = queue.shift() as Network;

            worker.evaluate(genome).then(function (result: number) {
              genome.score = -result;
              genome.score -= (genome.nodes.length - genome.input - genome.output +
                genome.connections.length + genome.gates.length) * growth;
              genome.score = isNaN(parseFloat(result as unknown as string)) ? -Infinity : genome.score;
              startWorker(worker);
            });
          };

          for (var i = 0; i < workers.length; i++) {
            startWorker(workers[i]);
          }
        });
      } as IFitnessFunction;

      options.fitnessPopulation = true;
    }

    // Intialise the NEAT instance
    options.network = this;

    // @todo: выкосить any
    var neat = new Neat(this.input, this.output, fitnessFunction, options);

    var error = -Infinity;
    var bestFitness = -Infinity;
    var bestGenome;

    while (!this.isEvolvingStopped && error < -targetError && (options.iterations === 0 || neat.generation < (options.iterations as number))) {
      let fittest = await neat.evolve();
      let fitness = fittest.score as number;
      error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;

      if (fitness > bestFitness) {
        bestFitness = fitness;
        bestGenome = fittest;
      }

      if (options.log && neat.generation % options.log === 0) {
        console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);
      }

      if (options.schedule && neat.generation % options.schedule.iterations === 0) {
        options.schedule.function({fitness: fitness, error: -error, iteration: neat.generation});
      }

      if (options.callback) {
        options.callback(
          fittest,
          {fitness: fitness, error: -error, iteration: neat.generation}
        )
      }
    }

    if (threads > 1) {
      //@ts-ignore
      for (var i = 0; i < workers.length; i++) {
        //@ts-ignore
        workers[i].terminate();
      }
    }

    if (typeof bestGenome !== 'undefined') {
      this.nodes = bestGenome.nodes;
      this.connections = bestGenome.connections;
      this.selfconns = bestGenome.selfconns;
      this.gates = bestGenome.gates;

      if (options.clear) this.clear();
    }

    const returnResult = {
      error: -error,
      iterations: neat.generation,
      time: Date.now() - start
    };

    resolveEvolve(returnResult);

    return returnResult;
  }

  /**
   * Creates a standalone function of the network which can be run without the
   * need of a library
   */
  standalone() {
    var present = [];
    var activations = [];
    var states = [];
    var lines = [];
    var functions = [];

    var i;
    for (i = 0; i < this.input; i++) {
      var node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);
    }

    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');

    // So we don't have to use expensive .indexOf()
    for (i = 0; i < this.nodes.length; i++) {
      (this.nodes[i] as any).index = i;
    }

    for (i = this.input; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      activations.push(node.activation);
      states.push(node.state);

      var functionIndex = present.indexOf(node.squash.name);

      if (functionIndex === -1) {
        functionIndex = present.length;
        present.push(node.squash.name);
        functions.push(node.squash.toString());
      }

      var incoming = [];
      for (var j = 0; j < node.connections.in.length; j++) {
        var conn = node.connections.in[j];
        var computation = `A[${(conn.from as any).index}] * ${conn.weight}`;

        if (conn.gater != null) {
          computation += ` * A[${(conn.gater as any).index}]`;
        }

        incoming.push(computation);
      }

      if (node.connections.self.weight) {
        let conn = node.connections.self;
        let computation = `S[${i}] * ${conn.weight}`;

        if (conn.gater != null) {
          computation += ` * A[${(conn.gater as any).index}]`;
        }

        incoming.push(computation);
      }

      var line1 = `S[${i}] = ${incoming.join(' + ')} + ${node.bias};`;
      var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node.mask ? ' * ' + node.mask : ''};`;
      lines.push(line1);
      lines.push(line2);
    }

    var output = [];
    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {
      output.push(`A[${i}]`);
    }

    lines.push(
      `return [${output.join(',')}];`
    );

    var total = '';
    total += `var F = [${functions.toString()}];\r\n`;
    total += `var A = [${activations.toString()}];\r\n`;
    total += `var S = [${states.toString()}];\r\n`;
    total += `activate = function(input){\r\n${lines.join('\r\n')}\r\n}`;

    return total;
  }

  /**
   * Serialize to send to workers efficiently
   */
  serialize() {
    var activations: number[] = [];
    var states: number[] = [];
    var conns: number[] = [];
    var squashes = [
      'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',
      'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',
      'ABSOLUTE', 'INVERSE', 'SELU'
    ];

    conns.push(this.input);
    conns.push(this.output);

    var i;
    for (i = 0; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      (node as any).index = i;
      activations.push(node.activation);
      states.push(node.state);
    }

    for (i = this.input; i < this.nodes.length; i++) {
      let node = this.nodes[i];
      conns.push((node as any).index as number);
      conns.push(node.bias);
      conns.push(squashes.indexOf(node.squash.name));

      conns.push(node.connections.self.weight);
      conns.push(node.connections.self.gater == null ? -1 : (node.connections.self.gater as any).index);

      for (var j = 0; j < node.connections.in.length; j++) {
        let conn = node.connections.in[j];

        conns.push((conn.from as any).index);
        conns.push(conn.weight);
        conns.push(conn.gater == null ? -1 : (conn.gater as any).index);
      }

      conns.push(-2); // stop token -> next node
    }

    return [activations, states, conns];
  }

  /**
   * Convert a json object to a network
   */
  static fromJSON(json: any): Network {
    var network = new Network(json.input, json.output);
    network.dropout = json.dropout;
    network.nodes = [];
    network.connections = [];

    var i;
    for (i = 0; i < json.nodes.length; i++) {
      network.nodes.push(NodeElement.fromJSON(json.nodes[i]));
    }

    for (i = 0; i < json.connections.length; i++) {
      var conn = json.connections[i];

      var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];
      connection.weight = conn.weight;

      if (conn.gater != null) {
        network.gate(network.nodes[conn.gater], connection);
      }
    }

    return network;
  }

  /**
   * Merge two networks into one
   */
  static merge(network1: Network, network2: Network) {
    // Create a copy of the networks
    network1 = Network.fromJSON(network1.toJSON());
    network2 = Network.fromJSON(network2.toJSON());

    // Check if output and input size are the same
    if (network1.output !== network2.input) {
      throw new Error('Output size of network1 should be the same as the input size of network2!');
    }

    // Redirect all connections from network2 input from network1 output
    var i;
    for (i = 0; i < network2.connections.length; i++) {
      let conn = network2.connections[i];
      if (conn.from.type === NodeTypeEnum.input) {
        let index = network2.nodes.indexOf(conn.from);

        // redirect
        conn.from = network1.nodes[network1.nodes.length - 1 - index];
      }
    }

    // Delete input nodes of network2
    for (i = network2.input - 1; i >= 0; i--) {
      network2.nodes.splice(i, 1);
    }

    // Change the node type of network1's output nodes (now hidden)
    for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {
      network1.nodes[i].type = NodeTypeEnum.hidden;
    }

    // Create one network from both networks
    network1.connections = network1.connections.concat(network2.connections);
    network1.nodes = network1.nodes.concat(network2.nodes);

    return network1;
  }

  /**
   * Create an offspring from two parent networks
   */
  static crossOver(network1: Network, network2: Network, equal?: boolean) {
    if (network1.input !== network2.input || network1.output !== network2.output) {
      throw new Error("Networks don't have the same input/output size!");
    }

    // Initialise offspring
    var offspring = new Network(network1.input, network1.output);
    offspring.connections = [];
    offspring.nodes = [];

    // Save scores and create a copy
    var score1 = network1.score || 0;
    var score2 = network2.score || 0;

    // Determine offspring node size
    var size;
    if (equal || score1 === score2) {
      let max = Math.max(network1.nodes.length, network2.nodes.length);
      let min = Math.min(network1.nodes.length, network2.nodes.length);
      size = Math.floor(Math.random() * (max - min + 1) + min);
    } else if (score1 > score2) {
      size = network1.nodes.length;
    } else {
      size = network2.nodes.length;
    }

    // Rename some variables for easier reading
    var outputSize = network1.output;

    // Set indexes so we don't need indexOf
    var i;
    for (i = 0; i < network1.nodes.length; i++) {
      (network1.nodes[i] as any).index = i;
    }

    for (i = 0; i < network2.nodes.length; i++) {
      (network2.nodes[i] as any).index = i;
    }

    // Assign nodes from parents to offspring
    for (i = 0; i < size; i++) {
      // Determine if an output node is needed
      var node;
      if (i < size - outputSize) {
        let random = Math.random();
        node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];
        let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];

        if (typeof node === 'undefined' || node.type === NodeTypeEnum.output) {
          node = other;
        }
      } else {
        if (Math.random() >= 0.5) {
          node = network1.nodes[network1.nodes.length + i - size];
        } else {
          node = network2.nodes[network2.nodes.length + i - size];
        }
      }

      var newNode = new NodeElement();
      newNode.bias = node.bias;
      newNode.squash = node.squash;
      newNode.type = node.type;

      offspring.nodes.push(newNode);
    }

    // Create arrays of connection genes
    var n1conns: { [key: number]: any } = {};
    var n2conns: { [key: number]: any } = {};

    // Normal connections
    for (i = 0; i < network1.connections.length; i++) {
      let conn = network1.connections[i];
      let data = {
        weight: conn.weight,
        from: (conn.from as any).index,
        to: (conn.to as any).index,
        gater: conn.gater != null ? (conn.gater as any).index : -1
      };
      n1conns[Connection.innovationID(data.from, data.to)] = data;
    }

    // Selfconnections
    for (i = 0; i < network1.selfconns.length; i++) {
      let conn = network1.selfconns[i];
      let data = {
        weight: conn.weight,
        from: (conn.from as any).index,
        to: (conn.to as any).index,
        gater: conn.gater != null ? (conn.gater as any).index : -1
      };
      n1conns[Connection.innovationID(data.from, data.to)] = data;
    }

    // Normal connections
    for (i = 0; i < network2.connections.length; i++) {
      let conn = network2.connections[i];
      let data = {
        weight: conn.weight,
        from: (conn.from as any).index,
        to: (conn.to as any).index,
        gater: conn.gater != null ? (conn.gater as any).index : -1
      };
      n2conns[Connection.innovationID(data.from, data.to)] = data;
    }

    // Selfconnections
    for (i = 0; i < network2.selfconns.length; i++) {
      let conn = network2.selfconns[i];
      let data = {
        weight: conn.weight,
        from: (conn.from as any).index,
        to: (conn.to as any).index,
        gater: conn.gater != null ? (conn.gater as any).index : -1
      };
      n2conns[Connection.innovationID(data.from, data.to)] = data;
    }

    // Split common conn genes from disjoint or excess conn genes
    var connections = [];
    var keys1 = Object.keys(n1conns) as unknown as number[];
    var keys2 = Object.keys(n2conns) as unknown as number[];
    for (i = keys1.length - 1; i >= 0; i--) {
      // Common gene
      if (typeof n2conns[keys1[i]] !== 'undefined') {
        let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];
        connections.push(conn);

        // Because deleting is expensive, just set it to some value
        n2conns[keys1[i]] = undefined;
      } else if (score1 >= score2 || equal) {
        connections.push(n1conns[keys1[i]]);
      }
    }

    // Excess/disjoint gene
    if (score2 >= score1 || equal) {
      for (i = 0; i < keys2.length; i++) {
        if (typeof n2conns[keys2[i]] !== 'undefined') {
          connections.push(n2conns[keys2[i]]);
        }
      }
    }

    // Add common conn genes uniformly
    for (i = 0; i < connections.length; i++) {
      let connData = connections[i];
      if (connData.to < size && connData.from < size) {
        let from = offspring.nodes[connData.from];
        let to = offspring.nodes[connData.to];
        let conn = offspring.connect(from, to)[0];

        conn.weight = connData.weight;

        if (connData.gater !== -1 && connData.gater < size) {
          offspring.gate(offspring.nodes[connData.gater], conn);
        }
      }
    }

    return offspring;
  }
}
//File content ./src/architecture/layer.ts
import Connection from "./connection";
import {IConnectionDescription} from "../types/methods-collection-types";
import Group from "./group";
import NodeElement from "./node";

/* Import */
import methods from '../methods/methods';
import {IConnectionDescriptor} from "../types/connection-descriptor";
import {NodeTypeEnum} from "../types/node-type-enum";

type TInputFunction = (from: Layer | Group, method?: IConnectionDescription, weight?: number) => Connection[];

export default class Layer {
  public nodes: (NodeElement | Group)[];
  public connections: IConnectionDescriptor;
  public output: Group;
  public input: TInputFunction;

  constructor() {
    this.output = null as unknown as Group;

    this.nodes = [];
    this.connections = {in: [], out: [], self: []};

    this.input = (() => {
    }) as unknown as TInputFunction;
  }

  /**
   * Activates all the nodes in the group
   */
  activate(value: number[]) {
    var values = [];

    if (typeof value !== "undefined" && value.length !== this.nodes.length) {
      throw new Error(
        "Array with values should be same as the amount of nodes!"
      );
    }

    for (var i = 0; i < this.nodes.length; i++) {
      var activation;
      if (typeof value === "undefined") {
        activation = this.nodes[i].activate();
      } else {
        activation = (this.nodes[i] as NodeElement).activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  }

  /**
   * Propagates all the node in the group
   */
  propagate(rate: number, momentum: number, target: number[]) {
    if (typeof target !== "undefined" && target.length !== this.nodes.length) {
      throw new Error(
        "Array with values should be same as the amount of nodes!"
      );
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === "undefined") {
        (this.nodes[i] as NodeElement).propagate(rate, momentum, true);
      } else {
        (this.nodes[i] as NodeElement).propagate(rate, momentum, true, target[i]);
      }
    }
  }

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect(target: Group | NodeElement | Layer, method?: IConnectionDescription, weight?: number): Connection[] {
    var connections: Connection[];
    if (target instanceof Group || target instanceof NodeElement) {
      connections = (this.output as Group).connect(target, method, weight);
    } else {
      connections = target.input(this, method, weight);
    }

    return connections;
  }

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate(connections: Connection[], method: IConnectionDescription) {
    this.output.gate(connections, method);
  }

  /**
   * Sets the value of a property for every node
   */
  set(values: NodeElement) {
    for (var i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];

      if (node instanceof NodeElement) {
        if (typeof values.bias !== "undefined") {
          node.bias = values.bias;
        }

        node.squash = values.squash || node.squash;
        node.type = values.type || node.type;
      } else {
        node.set(values);
      }
    }
  }

  /**
   * Disconnects all nodes from this group from another given group/node
   */
  disconnect(target: NodeElement | Group, twosided: boolean = false) {
    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            let conn = this.connections.out[k] as Connection;

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              let conn = this.connections.in[k] as Connection;

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          let conn = this.connections.out[j] as Connection;

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (k = this.connections.in.length - 1; k >= 0; k--) {
            let conn = this.connections.in[k] as Connection;

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(k, 1);
              break;
            }
          }
        }
      }
    }
  }

  /**
   * Clear the context of this group
   */
  clear() {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }

  static Dense(size: number): Layer {
    // Create the layer
    var layer = new Layer();

    // Init required nodes (in activation order)
    var block = new Group(size);

    layer.nodes.push(block);
    layer.output = block;

    layer.input = function (from, method, weight) {
      method = method || methods.connection.ALL_TO_ALL;
      return from.connect(block, method, weight);
    } as TInputFunction;

    return layer;
  }

  static LSTM(size: number) {
    // Create the layer
    var layer = new Layer();

    // Init required nodes (in activation order)
    var inputGate = new Group(size);
    var forgetGate = new Group(size);
    var memoryCell = new Group(size);
    var outputGate = new Group(size);
    var outputBlock = new Group(size);

    inputGate.set({
      bias: 1,
    });
    forgetGate.set({
      bias: 1,
    });
    outputGate.set({
      bias: 1,
    });

    // Set up internal connections
    memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
    memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
    memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
    var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
    var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);

    // Set up gates
    forgetGate.gate(forget, methods.gating.SELF);
    outputGate.gate(output, methods.gating.OUTPUT);

    // Add to nodes array
    layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];

    // Define output
    layer.output = outputBlock;

    layer.input = function (from, method, weight) {
      method = method || methods.connection.ALL_TO_ALL;
      var connections: Connection[] = [];

      var input: Connection[] = from.connect(memoryCell, method, weight);
      connections = connections.concat(input);

      connections = connections.concat(from.connect(inputGate, method, weight));
      connections = connections.concat(from.connect(outputGate, method, weight));
      connections = connections.concat(from.connect(forgetGate, method, weight));

      inputGate.gate(input, methods.gating.INPUT);

      return connections;
    };

    return layer;
  }

  static GRU(size: number) {
    // Create the layer
    var layer = new Layer();

    var updateGate = new Group(size);
    var inverseUpdateGate = new Group(size);
    var resetGate = new Group(size);
    var memoryCell = new Group(size);
    var output = new Group(size);
    var previousOutput = new Group(size);

    previousOutput.set({
      bias: 0,
      squash: methods.activation.IDENTITY,
      type: NodeTypeEnum.constant,
    });

    memoryCell.set({
      squash: methods.activation.TANH,
    });
    inverseUpdateGate.set({
      bias: 0,
      squash: methods.activation.INVERSE,
      type: NodeTypeEnum.constant,
    });
    updateGate.set({
      bias: 1,
    });
    resetGate.set({
      bias: 0,
    });

    // Update gate calculation
    previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL);

    // Inverse update gate calculation
    updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1);

    // Reset gate calculation
    previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL);

    // Memory calculation
    var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);

    resetGate.gate(reset, methods.gating.OUTPUT); // gate

    // Output calculation
    var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);
    var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);

    updateGate.gate(update1, methods.gating.OUTPUT);
    inverseUpdateGate.gate(update2, methods.gating.OUTPUT);

    // Previous output calculation
    output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1);

    // Add to nodes array
    layer.nodes = [
      updateGate,
      inverseUpdateGate,
      resetGate,
      memoryCell,
      output,
      previousOutput,
    ];

    layer.output = output;

    layer.input = function (from, method, weight) {
      if (from instanceof Layer) from = from.output;
      method = method || methods.connection.ALL_TO_ALL;
      var connections: Connection[] = [];

      connections = connections.concat(from.connect(updateGate, method, weight));
      connections = connections.concat(from.connect(resetGate, method, weight));
      connections = connections.concat(from.connect(memoryCell, method, weight));

      return connections;
    };

    return layer;
  }

  static Memory(size: number, memory: number) {
    // Create the layer
    var layer = new Layer();
    // Because the output can only be one group, we have to put the nodes all in óne group

    var previous = null;
    var i;
    for (i = 0; i < memory; i++) {
      var block = new Group(size);

      block.set({
        squash: methods.activation.IDENTITY,
        bias: 0,
        type: NodeTypeEnum.constant,
      });

      if (previous != null) {
        previous.connect(block, methods.connection.ONE_TO_ONE, 1);
      }

      layer.nodes.push(block);
      previous = block;
    }

    layer.nodes.reverse();

    for (i = 0; i < layer.nodes.length; i++) {
      (layer.nodes[i] as Group).nodes.reverse();
    }

    // Because output can only be óne group, fit all memory nodes in óne group
    var outputGroup = new Group(0);
    for (var group in layer.nodes) {
      outputGroup.nodes = outputGroup.nodes.concat((layer.nodes[group] as Group).nodes);
    }
    layer.output = outputGroup;

    layer.input = function (from, method, weight) {
      if (from instanceof Layer) from = from.output;
      method = method || methods.connection.ALL_TO_ALL;

      if (
        from.nodes.length !== (layer.nodes[layer.nodes.length - 1] as Group).nodes.length
      ) {
        throw new Error("Previous layer size must be same as memory size");
      }

      return from.connect(
        layer.nodes[layer.nodes.length - 1],
        method,
        weight
        // methods.connection.ONE_TO_ONE,
        // 1
      );
    };

    return layer;
  }
}
//File content ./src/architecture/group.ts
import NodeElement from "./node";
import Connection from "./connection";
import methods from "../methods/methods";
import {IConnectionDescription} from "../types/methods-collection-types";
import {IGate} from "../types/methods-gating-types";
import {IActivationFunction} from "../types/activation-types";
import Layer from './layer';

import config from "../config";
import {IConnectionDescriptor} from "../types/connection-descriptor";
import {NodeTypeEnum} from "../types/node-type-enum";

export default class Group {
  public nodes: NodeElement[];
  public connections: IConnectionDescriptor;

  constructor(size: number) {
    this.nodes = [];
    this.connections = {
      in: [],
      out: [],
      self: []
    };

    for (var i = 0; i < size; i++) {
      this.nodes.push(new NodeElement());
    }
  }

  /**
   * Activates all the nodes in the group
   */
  activate(value?: number[]): number[] {
    const values = [];

    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (let i = 0; i < this.nodes.length; i++) {
      let activation;
      if (typeof value === 'undefined') {
        activation = this.nodes[i].activate();
      } else {
        activation = this.nodes[i].activate(value[i]);
      }

      values.push(activation);
    }

    return values;
  }

  /**
   * Propagates all the node in the group
   */
  propagate(rate: number, momentum: number, target: number[]) {
    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {
      throw new Error('Array with values should be same as the amount of nodes!');
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (typeof target === 'undefined') {
        this.nodes[i].propagate(rate, momentum, true);
      } else {
        this.nodes[i].propagate(rate, momentum, true, target[i]);
      }
    }
  }

  /**
   * Connects the nodes in this group to nodes in another group or just a node
   */
  connect(target: Group | Layer | NodeElement, method?: IConnectionDescription, weight?: number) {
    var connections = [];
    var i, j;
    if (target instanceof Group) {
      if (typeof method === 'undefined') {
        if (this !== target) {
          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');
          method = methods.connection.ALL_TO_ALL;
        } else {
          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');
          method = methods.connection.ONE_TO_ONE;
        }
      }
      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {
        for (i = 0; i < this.nodes.length; i++) {
          for (j = 0; j < target.nodes.length; j++) {
            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;
            let connection = this.nodes[i].connect(target.nodes[j], weight);
            this.connections.out.push(connection[0]);
            target.connections.in.push(connection[0]);
            connections.push(connection[0]);
          }
        }
      } else if (method === methods.connection.ONE_TO_ONE) {
        if (this.nodes.length !== target.nodes.length) {
          throw new Error('From and To group must be the same size!');
        }

        for (i = 0; i < this.nodes.length; i++) {
          let connection = this.nodes[i].connect(target.nodes[i], weight);
          this.connections.self.push(connection[0]);
          connections.push(connection[0]);
        }
      }
    } else if (target instanceof Layer) {
      connections = target.input(this, method, weight);
    } else {
      for (i = 0; i < this.nodes.length; i++) {
        let connection = this.nodes[i].connect(target, weight);
        this.connections.out.push(connection[0]);
        connections.push(connection[0]);
      }
    }

    return connections;
  }

  /**
   * Make nodes from this group gate the given connection(s)
   */
  gate(connections: Connection | Connection[], method: IGate) {
    if (typeof method === 'undefined') {
      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');
    }

    if (!Array.isArray(connections)) {
      connections = [connections];
    }

    const nodes1: NodeElement[] = [];
    const nodes2: NodeElement[] = [];

    var i, j;
    for (i = 0; i < connections.length; i++) {
      var connection = connections[i];
      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);
      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);
    }

    switch (method) {
      case methods.gating.INPUT:
        for (i = 0; i < nodes2.length; i++) {
          let node = nodes2[i];
          let gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.in.length; j++) {
            let conn = node.connections.in[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.OUTPUT:
        for (i = 0; i < nodes1.length; i++) {
          let node = nodes1[i];
          let gater = this.nodes[i % this.nodes.length];

          for (j = 0; j < node.connections.out.length; j++) {
            let conn = node.connections.out[j];
            if (connections.includes(conn)) {
              gater.gate(conn);
            }
          }
        }
        break;
      case methods.gating.SELF:
        for (i = 0; i < nodes1.length; i++) {
          let node = nodes1[i];
          let gater = this.nodes[i % this.nodes.length];

          if (connections.includes(node.connections.self)) {
            gater.gate(node.connections.self);
          }
        }
    }
  }

  /**
   * Sets the value of a property for every node
   */
  set(values: { bias?: number; squash?: IActivationFunction; type?: NodeTypeEnum }) {
    for (var i = 0; i < this.nodes.length; i++) {
      if (typeof values.bias !== 'undefined') {
        this.nodes[i].bias = values.bias;
      }

      this.nodes[i].squash = values.squash || this.nodes[i].squash;
      this.nodes[i].type = values.type || this.nodes[i].type;
    }
  }

  disconnect(target: Group | NodeElement, twosided: boolean = false) {
    // In the future, disconnect will return a connection so indexOf can be used
    var i, j, k;
    if (target instanceof Group) {
      for (i = 0; i < this.nodes.length; i++) {
        for (j = 0; j < target.nodes.length; j++) {
          this.nodes[i].disconnect(target.nodes[j], twosided);

          for (k = this.connections.out.length - 1; k >= 0; k--) {
            let conn = this.connections.out[k] as Connection;

            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {
              this.connections.out.splice(k, 1);
              break;
            }
          }

          if (twosided) {
            for (k = this.connections.in.length - 1; k >= 0; k--) {
              let conn = this.connections.in[k] as Connection;

              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {
                this.connections.in.splice(k, 1);
                break;
              }
            }
          }
        }
      }
    } else {
      for (i = 0; i < this.nodes.length; i++) {
        this.nodes[i].disconnect(target, twosided);

        for (j = this.connections.out.length - 1; j >= 0; j--) {
          let conn = this.connections.out[j] as Connection;

          if (conn.from === this.nodes[i] && conn.to === target) {
            this.connections.out.splice(j, 1);
            break;
          }
        }

        if (twosided) {
          for (j = this.connections.in.length - 1; j >= 0; j--) {
            var conn = this.connections.in[j] as Connection;

            if (conn.from === target && conn.to === this.nodes[i]) {
              this.connections.in.splice(j, 1);
              break;
            }
          }
        }
      }
    }
  }

  /**
   * Clear the context of this group
   */
  clear() {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
  }
}
//File content ./src/architecture/connection.ts
//const Node = require('./node');
import NodeElement from './node';

type IXTrace = {
  nodes: NodeElement[];
  values: number[];
};

export default class Connection {
  public from: NodeElement;
  public to: NodeElement;
  public gain: number = 1;
  public weight: number;

  public elegibility: number = 0;
  public previousDeltaWeight: number = 0;
  public totalDeltaWeight: number = 0;

  public gater: NodeElement | null = null;

  public xtrace: IXTrace = {
    nodes: [],
    values: []
  };

  constructor (from: NodeElement, to: NodeElement, weight?: number) {
    this.from = from;
    this.to = to;

    this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;
  }

  toJSON() {
    return {
        weight: this.weight
    };
  }

  static innovationID (a: number, b: number): number {
    return 1 / 2 * (a + b) * (a + b + 1) + b;
  }
}//File content ./src/index.ts
import methods from './methods/methods';
import Connection from './architecture/connection';
import architect from './helpers/architect';
import Network from './architecture/network';
import config from './config';
import Group from './architecture/group';
import Layer from './architecture/layer';
import NodeElement from './architecture/node';
import Neat from './helpers/neat';
import * as multi from './multithreading/multi';

const helpers = {
  architect,
  Neat
};

export {
  methods,
  Connection,
  Network,
  config,
  Group,
  Layer,
  NodeElement,
  multi,
  helpers
};
//File content ./src/config.ts
export default {
  warnings: false
};
//File content ./src/helpers/architect.ts
/* Import */
import methods from '../methods/methods';
import Network from '../architecture/network';
import Layer from '../architecture/layer';
import Group from '../architecture/group';
import NodeElement from '../architecture/node';
import {NodeTypeEnum} from "../types/node-type-enum";
import addNode from "../methods/mutation/add-node";
import addConn from "../methods/mutation/add-conn";
import addBackConn from "../methods/mutation/add-back-conn";
import addSelfConn from "../methods/mutation/add-self-conn";
import addGate from "../methods/mutation/add-gate";

/*******************************************************************************
                                        architect
*******************************************************************************/

var architect = {
  /**
   * Constructs a network from a given array of connected nodes
   */
  Construct: function (list: (NodeElement | Group | Layer)[]) {
    // Create a network
    var network = new Network(0, 0);

    // Transform all groups into nodes
    var nodes: NodeElement[] = [];

    var i;
    for (i = 0; i < list.length; i++) {
      let j;
      if (list[i] instanceof Group) {
        for (j = 0; j < (list[i] as Group).nodes.length; j++) {
          nodes.push((list[i] as Group).nodes[j]);
        }
      } else if (list[i] instanceof Layer) {
        for (j = 0; j < (list[i] as Layer).nodes.length; j++) {
          for (var k = 0; k < ((list[i] as Layer).nodes[j] as Group).nodes.length; k++) {
            nodes.push(((list[i] as Layer).nodes[j] as Group).nodes[k]);
          }
        }
      } else if (list[i] instanceof NodeElement) {
        nodes.push(list[i] as NodeElement);
      }
    }

    // Determine input and output nodes
    var inputs = [];
    var outputs = [];
    for (i = nodes.length - 1; i >= 0; i--) {
      if (nodes[i].type === NodeTypeEnum.output || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {
        nodes[i].type = NodeTypeEnum.output;
        network.output++;
        outputs.push(nodes[i]);
        nodes.splice(i, 1);
      } else if (nodes[i].type === NodeTypeEnum.input || !nodes[i].connections.in.length) {
        nodes[i].type = NodeTypeEnum.input;
        network.input++;
        inputs.push(nodes[i]);
        nodes.splice(i, 1);
      }
    }

    // Input nodes are always first, output nodes are always last
    nodes = inputs.concat(nodes).concat(outputs);

    if (network.input === 0 || network.output === 0) {
      throw new Error('Given nodes have no clear input/output node!');
    }

    for (i = 0; i < nodes.length; i++) {
      let j;
      for (j = 0; j < nodes[i].connections.out.length; j++) {
        network.connections.push(nodes[i].connections.out[j]);
      }
      for (j = 0; j < nodes[i].connections.gated.length; j++) {
        network.gates.push(nodes[i].connections.gated[j]);
      }
      if (nodes[i].connections.self.weight !== 0) {
        network.selfconns.push(nodes[i].connections.self);
      }
    }

    network.nodes = nodes;

    return network;
  },

  /**
   * Creates a multilayer perceptron (MLP)
   */
  Perceptron: function (...args: number[]) {
    // Convert arguments to Array
    var layers = Array.prototype.slice.call(args);
    if (layers.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    // Create a list of nodes/groups
    var nodes = [];
    nodes.push(new Group(layers[0]));

    for (var i = 1; i < layers.length; i++) {
      var layer = layers[i];
      layer = new Group(layer);
      nodes.push(layer);
      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);
    }

    // Construct the network
    return architect.Construct(nodes);
  },

  /**
   * Creates a randomly connected network
   */
  Random: function (input: number, hidden: number, output: number, options?: {connections?: number; backconnections?: number; selfconnections?: number; gates?: number;}) {
    options = options || {};

    var connections = options.connections || hidden * 2;
    var backconnections = options.backconnections || 0;
    var selfconnections = options.selfconnections || 0;
    var gates = options.gates || 0;

    var network = new Network(input, output);

    var i;
    for (i = 0; i < hidden; i++) {
      network.mutate(addNode);
    }

    for (i = 0; i < connections - hidden; i++) {
      network.mutate(addConn);
    }

    for (i = 0; i < backconnections; i++) {
      network.mutate(addBackConn);
    }

    for (i = 0; i < selfconnections; i++) {
      network.mutate(addSelfConn);
    }

    for (i = 0; i < gates; i++) {
      network.mutate(addGate);
    }

    return network;
  },

  /**
   * Creates a long short-term memory network
   */
  LSTM: function (...inArgs: number[]) {
    var args = Array.prototype.slice.call(inArgs);
    if (args.length < 3) {
      throw new Error('You have to specify at least 3 layers');
    }

    var last = args.pop();

    var outputLayer;
    if (typeof last === 'number') {
      outputLayer = new Group(last);
      last = {};
    } else {
      outputLayer = new Group(args.pop()); // last argument
    }

    outputLayer.set({
      type: NodeTypeEnum.output
    });

    var options = {
      memoryToMemory: last.memoryToMemory || false,
      outputToMemory: last.outputToMemory || false,
      outputToGates: last.outputToGates || false,
      inputToOutput: last.inputToOutput === undefined ? true : last.inputToOutput,
      inputToDeep: last.inputToDeep === undefined ? true : last.inputToDeep
    };

    var inputLayer = new Group(args.shift()); // first argument
    inputLayer.set({
      type: NodeTypeEnum.input
    });

    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var block = blocks[i];

      // Init required nodes (in activation order)
      var inputGate = new Group(block);
      var forgetGate = new Group(block);
      var memoryCell = new Group(block);
      var outputGate = new Group(block);
      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);

      inputGate.set({
        bias: 1
      });
      forgetGate.set({
        bias: 1
      });
      outputGate.set({
        bias: 1
      });

      // Connect the input with all the nodes
      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);
      previous.connect(inputGate, methods.connection.ALL_TO_ALL);
      previous.connect(outputGate, methods.connection.ALL_TO_ALL);
      previous.connect(forgetGate, methods.connection.ALL_TO_ALL);

      // Set up internal connections
      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);
      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);
      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);
      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);
      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL);

      // Set up gates
      inputGate.gate(input, methods.gating.INPUT);
      forgetGate.gate(forget, methods.gating.SELF);
      outputGate.gate(output, methods.gating.OUTPUT);

      // Input to all memory cells
      if (options.inputToDeep && i > 0) {
        let input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);
        inputGate.gate(input, methods.gating.INPUT);
      }

      // Optional connections
      if (options.memoryToMemory) {
        let input = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToMemory) {
        let input = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);
        inputGate.gate(input, methods.gating.INPUT);
      }

      if (options.outputToGates) {
        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);
        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);
        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);
      }

      // Add to array
      nodes.push(inputGate);
      nodes.push(forgetGate);
      nodes.push(memoryCell);
      nodes.push(outputGate);
      if (i !== blocks.length - 1) nodes.push(outputBlock);

      previous = outputBlock;
    }

    // input to output direct connection
    if (options.inputToOutput) {
      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);
    }

    nodes.push(outputLayer);
    return architect.Construct(nodes);
  },

  /**
   * Creates a gated recurrent unit network
   */
  GRU: function (...inArgs: number[]) {
    var args = Array.prototype.slice.call(inArgs);
    if (args.length < 3) {
      throw new Error('not enough layers (minimum 3) !!');
    }

    var inputLayer = new Group(args.shift()); // first argument
    var outputLayer = new Group(args.pop()); // last argument
    var blocks = args; // all the arguments in the middle

    var nodes = [];
    nodes.push(inputLayer);

    var previous: Group | Layer = inputLayer;
    for (var i = 0; i < blocks.length; i++) {
      var layer = Layer.GRU(blocks[i]);
      previous.connect(layer);
      previous = layer;

      nodes.push(layer);
    }

    previous.connect(outputLayer);
    nodes.push(outputLayer);

    return architect.Construct(nodes);
  },

  /**
   * Creates a hopfield network of the given size
   */
  Hopfield: function (size: number) {
    var input = new Group(size);
    var output = new Group(size);

    input.connect(output, methods.connection.ALL_TO_ALL);

    input.set({
      type: NodeTypeEnum.input
    });
    output.set({
      squash: methods.activation.STEP,
      type: NodeTypeEnum.output
    });

    return architect.Construct([input, output]);
  },

  /**
   * Creates a NARX network (remember previous inputs/outputs)
   */
  NARX: function (inputSize: number, hiddenLayers: number | number[], outputSize: number, previousInput: number, previousOutput: number) {
    if (!Array.isArray(hiddenLayers)) {
      hiddenLayers = [hiddenLayers];
    }

    var nodes = [];

    var input = Layer.Dense(inputSize);
    var inputMemory = Layer.Memory(inputSize, previousInput);
    var hidden = [];
    var output = Layer.Dense(outputSize);
    var outputMemory = Layer.Memory(outputSize, previousOutput);

    nodes.push(input);
    nodes.push(outputMemory);

    for (var i = 0; i < hiddenLayers.length; i++) {
      var hiddenLayer = Layer.Dense(hiddenLayers[i]);
      hidden.push(hiddenLayer);
      nodes.push(hiddenLayer);
      if (typeof hidden[i - 1] !== 'undefined') {
        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);
      }
    }

    nodes.push(inputMemory);
    nodes.push(output);

    input.connect(hidden[0], methods.connection.ALL_TO_ALL);
    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);
    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);
    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);
    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);
    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);

    input.set(new NodeElement(NodeTypeEnum.input));
    output.set(new NodeElement(NodeTypeEnum.output));

    return architect.Construct(nodes);
  }
};

export default architect;
//File content ./src/helpers/neat.ts
import Network from "../architecture/network";
import { ICrossover } from "../methods/crossover";
import { IMutation } from "../methods/mutation";
import { ISelection } from "../methods/selection";

import methods from '../methods/methods';
import config from '../config';
import addNode from "../methods/mutation/add-node";
import addConn from "../methods/mutation/add-conn";
import addGate from "../methods/mutation/add-gate";

/* Easier variable naming */
var selection = methods.selection;

/*******************************************************************************
                                         NEAT
*******************************************************************************/

// type INetworkFitnessFunction = (population: Network) => number;
// type IGenomeFitnessFunction = (genome: Network[]) => Promise<undefined>;
// type IFitnessFunction = INetworkFitnessFunction | IGenomeFitnessFunction;
export type IFitnessFunction = (popGenome: Network | Network[]) => (number | Promise<undefined>);

export interface INeatOptions {
  equal?: boolean;
  clear?: boolean;
  popsize?: number;
  elitism?: number;
  provenance?: number;
  mutationRate?: number;
  mutationAmount?: number;
  fitnessPopulation?: boolean;
  selection?: ISelection;
  crossover?: ICrossover[];
  mutation?: IMutation[];
  network?: Network;

  maxNodes?: number;
  maxConns?: number;
  maxGates?: number;

  mutationSelection?: (genome: Network) => IMutation;
}

export default class Neat {
  public input: number;
  public output: number;
  public fitness: IFitnessFunction;
  public equal: boolean;
  public clear: boolean;
  public popsize: number;
  public elitism: number;
  public provenance: number;
  public mutationRate: number;
  public mutationAmount: number;
  fitnessPopulation: boolean;
  selection: ISelection;
  crossover: ICrossover[];
  mutation: IMutation[];
  template?: Network;

  maxNodes: number;
  maxConns: number;
  maxGates: number;

  generation: number;

  population: Network[] = [];

  constructor(input: number, output: number, fitness: IFitnessFunction, options: INeatOptions) {
    this.input = input; // The input size of the networks
    this.output = output; // The output size of the networks
    this.fitness = fitness; // The fitness function to evaluate the networks

    // Configure options
    options = options || {};
    this.equal = options.equal || false;
    this.clear = options.clear || false;
    this.popsize = options.popsize || 50;
    this.elitism = options.elitism || 0;
    this.provenance = options.provenance || 0;
    this.mutationRate = options.mutationRate || 0.3;
    this.mutationAmount = options.mutationAmount || 1;

    this.fitnessPopulation = options.fitnessPopulation || false;

    this.selection = options.selection || methods.selection.POWER;
    this.crossover = options.crossover || [
      methods.crossover.SINGLE_POINT,
      methods.crossover.TWO_POINT,
      methods.crossover.UNIFORM,
      methods.crossover.AVERAGE
    ];
    this.mutation = options.mutation || methods.mutation.FFW;

    this.template = options.network || undefined;

    this.maxNodes = options.maxNodes || Infinity;
    this.maxConns = options.maxConns || Infinity;
    this.maxGates = options.maxGates || Infinity;

    // Custom mutation selection function if given
    this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;

    // Generation counter
    this.generation = 0;

    // Initialise the genomes
    this.createPool(this.template);
  }

  /**
   * Create the initial pool of genomes
   */
  createPool(network: any) {
    this.population = [];

    for (var i = 0; i < this.popsize; i++) {
      var copy;
      if (this.template) {
        copy = Network.fromJSON(network.toJSON());
      } else {
        copy = new Network(this.input, this.output);
      }
      copy.score = undefined;
      this.population.push(copy);
    }
  }

  /**
   * Evaluates, selects, breeds and mutates population
   */
  async evolve() {
    // Check if evaluated, sort the population
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      await this.evaluate();
    }
    this.sort();

    var fittest = Network.fromJSON(this.population[0].toJSON());
    fittest.score = this.population[0].score;

    var newPopulation = [];

    // Elitism
    var elitists = [];
    for (var i = 0; i < this.elitism; i++) {
      elitists.push(this.population[i]);
    }

    // Provenance
    for (i = 0; i < this.provenance; i++) {
      newPopulation.push(Network.fromJSON((this.template as Network).toJSON()));
    }

    // Breed the next individuals
    for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {
      newPopulation.push(this.getOffspring());
    }

    // Replace the old population with the new population
    this.population = newPopulation;
    this.mutate();

    this.population.push(...elitists);

    // Reset the scores
    for (i = 0; i < this.population.length; i++) {
      this.population[i].score = undefined;
    }

    this.generation++;

    return fittest;
  }

  /**
   * Breeds two parents into an offspring, population MUST be surted
   */
  getOffspring() {
    var parent1 = this.getParent() as Network;
    var parent2 = this.getParent() as Network;

    return Network.crossOver(parent1, parent2, this.equal);
  }

  /**
   * Selects a random mutation method for a genome according to the parameters
   */
  selectMutationMethod(genome: Network) {
    const mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];

    if (mutationMethod === addNode && genome.nodes.length >= this.maxNodes) {
      if (config.warnings) console.warn('maxNodes exceeded!');
      return;
    } else if (mutationMethod === addConn && genome.connections.length >= this.maxConns) {
      if (config.warnings) console.warn('maxConns exceeded!');
      return;
    } else if (mutationMethod === addGate && genome.gates.length >= this.maxGates) {
      if (config.warnings) console.warn('maxGates exceeded!');
      return;
    }

    return mutationMethod;
  }

  /**
   * Mutates the given (or current) population
   */
  mutate() {
    // Elitist genomes should not be included
    for (var i = 0; i < this.population.length; i++) {
      if (Math.random() <= this.mutationRate) {
        for (var j = 0; j < this.mutationAmount; j++) {
          const mutationMethod = this.selectMutationMethod(this.population[i]);
          this.population[i].mutate(mutationMethod);
        }
      }
    }
  }

  /**
   * Evaluates the current population
   */
  async evaluate() {
    var i;
    if (this.fitnessPopulation) {
      if (this.clear) {
        for (i = 0; i < this.population.length; i++) {
          this.population[i].clear();
        }
      }
      await this.fitness(this.population);
    } else {
      for (i = 0; i < this.population.length; i++) {
        var genome = this.population[i];
        if (this.clear) {
          genome.clear();
        }
        genome.score = await this.fitness(genome);
      }
    }
  }

  /**
   * Sorts the population by score
   */
  sort() {
    this.population.sort(function (a, b) {
      // @ts-ignore
      return b.score - a.score;
    });
  }

  /**
   * Returns the fittest genome of the current population
   */
  getFittest() {
    // Check if evaluated
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }
    // @ts-ignore
    if (this.population[0].score < this.population[1].score) {
      this.sort();
    }

    return this.population[0];
  }

  /**
   * Returns the average fitness of the current population
   */
  getAverage() {
    if (typeof this.population[this.population.length - 1].score === 'undefined') {
      this.evaluate();
    }

    var score = 0;
    for (var i = 0; i < this.population.length; i++) {
      // @ts-ignore
      score += this.population[i].score;
    }

    return score / this.population.length;
  }

  /**
   * Gets a genome based on the selection function
   * @todo: вынести реализацию в функции селекции
   * @return {Network} genome
   */
  getParent() {
    var i;
    switch (this.selection.name) {
      case selection.POWER.name:
        // @ts-ignore
        if (this.population[0].score < this.population[1].score) this.sort();

        var index = Math.floor(Math.pow(Math.random(), (this.selection.power as number)) * this.population.length);
        return this.population[index];
      case selection.FITNESS_PROPORTIONATE.name:
        // As negative fitnesses are possible
        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values
        // this is unnecessarily run for every individual, should be changed

        var totalFitness = 0;
        var minimalFitness = 0;
        for (i = 0; i < this.population.length; i++) {
          var score = this.population[i].score as number;
          minimalFitness = score < minimalFitness ? score : minimalFitness;
          totalFitness += score;
        }

        minimalFitness = Math.abs(minimalFitness);
        totalFitness += minimalFitness * this.population.length;

        var random = Math.random() * totalFitness;
        var value = 0;

        for (i = 0; i < this.population.length; i++) {
          let genome = this.population[i];
          value += (genome.score as number) + minimalFitness;
          if (random < value) return genome;
        }

        // if all scores equal, return random genome
        return this.population[Math.floor(Math.random() * this.population.length)];
      case selection.TOURNAMENT.name:
        if ((this.selection.size as number) > this.popsize) {
          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');
        }

        // Create a tournament
        var individuals = [];
        for (i = 0; i < (this.selection.size as number); i++) {
          let random = this.population[Math.floor(Math.random() * this.population.length)];
          individuals.push(random);
        }

        // Sort the tournament individuals by score
        individuals.sort(function (a, b) {
          // @ts-ignore
          return b.score - a.score;
        });

        // Select an individual
        for (i = 0; i < (this.selection.size as number); i++) {
          if (Math.random() < (this.selection.probability as number) || i === (this.selection.size as number) - 1) {
            return individuals[i];
          }
        }
    }
  }

  /**
   * Export the current population to a json object
   */
  export() {
    var json = [];
    for (var i = 0; i < this.population.length; i++) {
      var genome = this.population[i];
      json.push(genome.toJSON());
    }

    return json;
  }

  /**
   * Import population from a json object
   */
  import(json: any) {
    var population = [];
    for (var i = 0; i < json.length; i++) {
      var genome = json[i];
      population.push(Network.fromJSON(genome));
    }
    this.population = population;
    this.popsize = population.length;
  }
}
