/*!
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE
 *
 */
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://MasterNeat/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./src/architecture/architect.ts":
/*!***************************************!*\
  !*** ./src/architecture/architect.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* Import */\nconst methods_1 = __importDefault(__webpack_require__(/*! ../methods/methods */ \"./src/methods/methods.ts\"));\nconst network_1 = __importDefault(__webpack_require__(/*! ./network */ \"./src/architecture/network.ts\"));\nconst layer_1 = __importDefault(__webpack_require__(/*! ./layer */ \"./src/architecture/layer.ts\"));\nconst group_1 = __importDefault(__webpack_require__(/*! ./group */ \"./src/architecture/group.ts\"));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"./src/architecture/node.ts\"));\nconst node_type_enum_1 = __webpack_require__(/*! ../types/node-type-enum */ \"./src/types/node-type-enum.ts\");\nconst add_node_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/add-node */ \"./src/methods/mutation/add-node.ts\"));\nconst add_conn_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/add-conn */ \"./src/methods/mutation/add-conn.ts\"));\nconst add_back_conn_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/add-back-conn */ \"./src/methods/mutation/add-back-conn.ts\"));\nconst add_self_conn_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/add-self-conn */ \"./src/methods/mutation/add-self-conn.ts\"));\nconst add_gate_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/add-gate */ \"./src/methods/mutation/add-gate.ts\"));\n/*******************************************************************************\n                                        architect\n*******************************************************************************/\nvar architect = {\n    /**\n     * Constructs a network from a given array of connected nodes\n     */\n    Construct: function (list) {\n        // Create a network\n        var network = new network_1.default(0, 0);\n        // Transform all groups into nodes\n        var nodes = [];\n        var i;\n        for (i = 0; i < list.length; i++) {\n            let j;\n            if (list[i] instanceof group_1.default) {\n                for (j = 0; j < list[i].nodes.length; j++) {\n                    nodes.push(list[i].nodes[j]);\n                }\n            }\n            else if (list[i] instanceof layer_1.default) {\n                for (j = 0; j < list[i].nodes.length; j++) {\n                    for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {\n                        nodes.push(list[i].nodes[j].nodes[k]);\n                    }\n                }\n            }\n            else if (list[i] instanceof node_1.default) {\n                nodes.push(list[i]);\n            }\n        }\n        // Determine input and output nodes\n        var inputs = [];\n        var outputs = [];\n        for (i = nodes.length - 1; i >= 0; i--) {\n            if (nodes[i].type === node_type_enum_1.NodeTypeEnum.output || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {\n                nodes[i].type = node_type_enum_1.NodeTypeEnum.output;\n                network.output++;\n                outputs.push(nodes[i]);\n                nodes.splice(i, 1);\n            }\n            else if (nodes[i].type === node_type_enum_1.NodeTypeEnum.input || !nodes[i].connections.in.length) {\n                nodes[i].type = node_type_enum_1.NodeTypeEnum.input;\n                network.input++;\n                inputs.push(nodes[i]);\n                nodes.splice(i, 1);\n            }\n        }\n        // Input nodes are always first, output nodes are always last\n        nodes = inputs.concat(nodes).concat(outputs);\n        if (network.input === 0 || network.output === 0) {\n            throw new Error('Given nodes have no clear input/output node!');\n        }\n        for (i = 0; i < nodes.length; i++) {\n            let j;\n            for (j = 0; j < nodes[i].connections.out.length; j++) {\n                network.connections.push(nodes[i].connections.out[j]);\n            }\n            for (j = 0; j < nodes[i].connections.gated.length; j++) {\n                network.gates.push(nodes[i].connections.gated[j]);\n            }\n            if (nodes[i].connections.self.weight !== 0) {\n                network.selfconns.push(nodes[i].connections.self);\n            }\n        }\n        network.nodes = nodes;\n        return network;\n    },\n    /**\n     * Creates a multilayer perceptron (MLP)\n     */\n    Perceptron: function (...args) {\n        // Convert arguments to Array\n        var layers = Array.prototype.slice.call(args);\n        if (layers.length < 3) {\n            throw new Error('You have to specify at least 3 layers');\n        }\n        // Create a list of nodes/groups\n        var nodes = [];\n        nodes.push(new group_1.default(layers[0]));\n        for (var i = 1; i < layers.length; i++) {\n            var layer = layers[i];\n            layer = new group_1.default(layer);\n            nodes.push(layer);\n            nodes[i - 1].connect(nodes[i], methods_1.default.connection.ALL_TO_ALL);\n        }\n        // Construct the network\n        return architect.Construct(nodes);\n    },\n    /**\n     * Creates a randomly connected network\n     */\n    Random: function (input, hidden, output, options) {\n        options = options || {};\n        var connections = options.connections || hidden * 2;\n        var backconnections = options.backconnections || 0;\n        var selfconnections = options.selfconnections || 0;\n        var gates = options.gates || 0;\n        var network = new network_1.default(input, output);\n        var i;\n        for (i = 0; i < hidden; i++) {\n            network.mutate(add_node_1.default);\n        }\n        for (i = 0; i < connections - hidden; i++) {\n            network.mutate(add_conn_1.default);\n        }\n        for (i = 0; i < backconnections; i++) {\n            network.mutate(add_back_conn_1.default);\n        }\n        for (i = 0; i < selfconnections; i++) {\n            network.mutate(add_self_conn_1.default);\n        }\n        for (i = 0; i < gates; i++) {\n            network.mutate(add_gate_1.default);\n        }\n        return network;\n    },\n    /**\n     * Creates a long short-term memory network\n     */\n    LSTM: function (...inArgs) {\n        var args = Array.prototype.slice.call(inArgs);\n        if (args.length < 3) {\n            throw new Error('You have to specify at least 3 layers');\n        }\n        var last = args.pop();\n        var outputLayer;\n        if (typeof last === 'number') {\n            outputLayer = new group_1.default(last);\n            last = {};\n        }\n        else {\n            outputLayer = new group_1.default(args.pop()); // last argument\n        }\n        outputLayer.set({\n            type: node_type_enum_1.NodeTypeEnum.output\n        });\n        var options = {\n            memoryToMemory: last.memoryToMemory || false,\n            outputToMemory: last.outputToMemory || false,\n            outputToGates: last.outputToGates || false,\n            inputToOutput: last.inputToOutput === undefined ? true : last.inputToOutput,\n            inputToDeep: last.inputToDeep === undefined ? true : last.inputToDeep\n        };\n        var inputLayer = new group_1.default(args.shift()); // first argument\n        inputLayer.set({\n            type: node_type_enum_1.NodeTypeEnum.input\n        });\n        var blocks = args; // all the arguments in the middle\n        var nodes = [];\n        nodes.push(inputLayer);\n        var previous = inputLayer;\n        for (var i = 0; i < blocks.length; i++) {\n            var block = blocks[i];\n            // Init required nodes (in activation order)\n            var inputGate = new group_1.default(block);\n            var forgetGate = new group_1.default(block);\n            var memoryCell = new group_1.default(block);\n            var outputGate = new group_1.default(block);\n            var outputBlock = i === blocks.length - 1 ? outputLayer : new group_1.default(block);\n            inputGate.set({\n                bias: 1\n            });\n            forgetGate.set({\n                bias: 1\n            });\n            outputGate.set({\n                bias: 1\n            });\n            // Connect the input with all the nodes\n            var input = previous.connect(memoryCell, methods_1.default.connection.ALL_TO_ALL);\n            previous.connect(inputGate, methods_1.default.connection.ALL_TO_ALL);\n            previous.connect(outputGate, methods_1.default.connection.ALL_TO_ALL);\n            previous.connect(forgetGate, methods_1.default.connection.ALL_TO_ALL);\n            // Set up internal connections\n            memoryCell.connect(inputGate, methods_1.default.connection.ALL_TO_ALL);\n            memoryCell.connect(forgetGate, methods_1.default.connection.ALL_TO_ALL);\n            memoryCell.connect(outputGate, methods_1.default.connection.ALL_TO_ALL);\n            var forget = memoryCell.connect(memoryCell, methods_1.default.connection.ONE_TO_ONE);\n            var output = memoryCell.connect(outputBlock, methods_1.default.connection.ALL_TO_ALL);\n            // Set up gates\n            inputGate.gate(input, methods_1.default.gating.INPUT);\n            forgetGate.gate(forget, methods_1.default.gating.SELF);\n            outputGate.gate(output, methods_1.default.gating.OUTPUT);\n            // Input to all memory cells\n            if (options.inputToDeep && i > 0) {\n                let input = inputLayer.connect(memoryCell, methods_1.default.connection.ALL_TO_ALL);\n                inputGate.gate(input, methods_1.default.gating.INPUT);\n            }\n            // Optional connections\n            if (options.memoryToMemory) {\n                let input = memoryCell.connect(memoryCell, methods_1.default.connection.ALL_TO_ELSE);\n                inputGate.gate(input, methods_1.default.gating.INPUT);\n            }\n            if (options.outputToMemory) {\n                let input = outputLayer.connect(memoryCell, methods_1.default.connection.ALL_TO_ALL);\n                inputGate.gate(input, methods_1.default.gating.INPUT);\n            }\n            if (options.outputToGates) {\n                outputLayer.connect(inputGate, methods_1.default.connection.ALL_TO_ALL);\n                outputLayer.connect(forgetGate, methods_1.default.connection.ALL_TO_ALL);\n                outputLayer.connect(outputGate, methods_1.default.connection.ALL_TO_ALL);\n            }\n            // Add to array\n            nodes.push(inputGate);\n            nodes.push(forgetGate);\n            nodes.push(memoryCell);\n            nodes.push(outputGate);\n            if (i !== blocks.length - 1)\n                nodes.push(outputBlock);\n            previous = outputBlock;\n        }\n        // input to output direct connection\n        if (options.inputToOutput) {\n            inputLayer.connect(outputLayer, methods_1.default.connection.ALL_TO_ALL);\n        }\n        nodes.push(outputLayer);\n        return architect.Construct(nodes);\n    },\n    /**\n     * Creates a gated recurrent unit network\n     */\n    GRU: function (...inArgs) {\n        var args = Array.prototype.slice.call(inArgs);\n        if (args.length < 3) {\n            throw new Error('not enough layers (minimum 3) !!');\n        }\n        var inputLayer = new group_1.default(args.shift()); // first argument\n        var outputLayer = new group_1.default(args.pop()); // last argument\n        var blocks = args; // all the arguments in the middle\n        var nodes = [];\n        nodes.push(inputLayer);\n        var previous = inputLayer;\n        for (var i = 0; i < blocks.length; i++) {\n            var layer = layer_1.default.GRU(blocks[i]);\n            previous.connect(layer);\n            previous = layer;\n            nodes.push(layer);\n        }\n        previous.connect(outputLayer);\n        nodes.push(outputLayer);\n        return architect.Construct(nodes);\n    },\n    /**\n     * Creates a hopfield network of the given size\n     */\n    Hopfield: function (size) {\n        var input = new group_1.default(size);\n        var output = new group_1.default(size);\n        input.connect(output, methods_1.default.connection.ALL_TO_ALL);\n        input.set({\n            type: node_type_enum_1.NodeTypeEnum.input\n        });\n        output.set({\n            squash: methods_1.default.activation.STEP,\n            type: node_type_enum_1.NodeTypeEnum.output\n        });\n        return architect.Construct([input, output]);\n    },\n    /**\n     * Creates a NARX network (remember previous inputs/outputs)\n     */\n    NARX: function (inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {\n        if (!Array.isArray(hiddenLayers)) {\n            hiddenLayers = [hiddenLayers];\n        }\n        var nodes = [];\n        var input = layer_1.default.Dense(inputSize);\n        var inputMemory = layer_1.default.Memory(inputSize, previousInput);\n        var hidden = [];\n        var output = layer_1.default.Dense(outputSize);\n        var outputMemory = layer_1.default.Memory(outputSize, previousOutput);\n        nodes.push(input);\n        nodes.push(outputMemory);\n        for (var i = 0; i < hiddenLayers.length; i++) {\n            var hiddenLayer = layer_1.default.Dense(hiddenLayers[i]);\n            hidden.push(hiddenLayer);\n            nodes.push(hiddenLayer);\n            if (typeof hidden[i - 1] !== 'undefined') {\n                hidden[i - 1].connect(hiddenLayer, methods_1.default.connection.ALL_TO_ALL);\n            }\n        }\n        nodes.push(inputMemory);\n        nodes.push(output);\n        input.connect(hidden[0], methods_1.default.connection.ALL_TO_ALL);\n        input.connect(inputMemory, methods_1.default.connection.ONE_TO_ONE, 1);\n        inputMemory.connect(hidden[0], methods_1.default.connection.ALL_TO_ALL);\n        hidden[hidden.length - 1].connect(output, methods_1.default.connection.ALL_TO_ALL);\n        output.connect(outputMemory, methods_1.default.connection.ONE_TO_ONE, 1);\n        outputMemory.connect(hidden[0], methods_1.default.connection.ALL_TO_ALL);\n        input.set(new node_1.default(node_type_enum_1.NodeTypeEnum.input));\n        output.set(new node_1.default(node_type_enum_1.NodeTypeEnum.output));\n        return architect.Construct(nodes);\n    }\n};\nexports[\"default\"] = architect;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/architect.ts?");

/***/ }),

/***/ "./src/architecture/connection.ts":
/*!****************************************!*\
  !*** ./src/architecture/connection.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Connection {\n    constructor(from, to, weight) {\n        this.gain = 1;\n        this.elegibility = 0;\n        this.previousDeltaWeight = 0;\n        this.totalDeltaWeight = 0;\n        this.gater = null;\n        this.xtrace = {\n            nodes: [],\n            values: []\n        };\n        this.from = from;\n        this.to = to;\n        this.weight = (typeof weight === 'undefined') ? Math.random() * 0.2 - 0.1 : weight;\n    }\n    toJSON() {\n        return {\n            weight: this.weight\n        };\n    }\n    static innovationID(a, b) {\n        return 1 / 2 * (a + b) * (a + b + 1) + b;\n    }\n}\nexports[\"default\"] = Connection;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/connection.ts?");

/***/ }),

/***/ "./src/architecture/group.ts":
/*!***********************************!*\
  !*** ./src/architecture/group.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"./src/architecture/node.ts\"));\nconst methods_1 = __importDefault(__webpack_require__(/*! ../methods/methods */ \"./src/methods/methods.ts\"));\nconst layer_1 = __importDefault(__webpack_require__(/*! ./layer */ \"./src/architecture/layer.ts\"));\nconst config_1 = __importDefault(__webpack_require__(/*! ../config */ \"./src/config.ts\"));\nclass Group {\n    constructor(size) {\n        this.nodes = [];\n        this.connections = {\n            in: [],\n            out: [],\n            self: []\n        };\n        for (var i = 0; i < size; i++) {\n            this.nodes.push(new node_1.default());\n        }\n    }\n    /**\n     * Activates all the nodes in the group\n     */\n    activate(value) {\n        const values = [];\n        if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\n            throw new Error('Array with values should be same as the amount of nodes!');\n        }\n        for (let i = 0; i < this.nodes.length; i++) {\n            let activation;\n            if (typeof value === 'undefined') {\n                activation = this.nodes[i].activate();\n            }\n            else {\n                activation = this.nodes[i].activate(value[i]);\n            }\n            values.push(activation);\n        }\n        return values;\n    }\n    /**\n     * Propagates all the node in the group\n     */\n    propagate(rate, momentum, target) {\n        if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\n            throw new Error('Array with values should be same as the amount of nodes!');\n        }\n        for (var i = this.nodes.length - 1; i >= 0; i--) {\n            if (typeof target === 'undefined') {\n                this.nodes[i].propagate(rate, momentum, true);\n            }\n            else {\n                this.nodes[i].propagate(rate, momentum, true, target[i]);\n            }\n        }\n    }\n    /**\n     * Connects the nodes in this group to nodes in another group or just a node\n     */\n    connect(target, method, weight) {\n        var connections = [];\n        var i, j;\n        if (target instanceof Group) {\n            if (typeof method === 'undefined') {\n                if (this !== target) {\n                    if (config_1.default.warnings)\n                        console.warn('No group connection specified, using ALL_TO_ALL');\n                    method = methods_1.default.connection.ALL_TO_ALL;\n                }\n                else {\n                    if (config_1.default.warnings)\n                        console.warn('No group connection specified, using ONE_TO_ONE');\n                    method = methods_1.default.connection.ONE_TO_ONE;\n                }\n            }\n            if (method === methods_1.default.connection.ALL_TO_ALL || method === methods_1.default.connection.ALL_TO_ELSE) {\n                for (i = 0; i < this.nodes.length; i++) {\n                    for (j = 0; j < target.nodes.length; j++) {\n                        if (method === methods_1.default.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j])\n                            continue;\n                        let connection = this.nodes[i].connect(target.nodes[j], weight);\n                        this.connections.out.push(connection[0]);\n                        target.connections.in.push(connection[0]);\n                        connections.push(connection[0]);\n                    }\n                }\n            }\n            else if (method === methods_1.default.connection.ONE_TO_ONE) {\n                if (this.nodes.length !== target.nodes.length) {\n                    throw new Error('From and To group must be the same size!');\n                }\n                for (i = 0; i < this.nodes.length; i++) {\n                    let connection = this.nodes[i].connect(target.nodes[i], weight);\n                    this.connections.self.push(connection[0]);\n                    connections.push(connection[0]);\n                }\n            }\n        }\n        else if (target instanceof layer_1.default) {\n            connections = target.input(this, method, weight);\n        }\n        else {\n            for (i = 0; i < this.nodes.length; i++) {\n                let connection = this.nodes[i].connect(target, weight);\n                this.connections.out.push(connection[0]);\n                connections.push(connection[0]);\n            }\n        }\n        return connections;\n    }\n    /**\n     * Make nodes from this group gate the given connection(s)\n     */\n    gate(connections, method) {\n        if (typeof method === 'undefined') {\n            throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');\n        }\n        if (!Array.isArray(connections)) {\n            connections = [connections];\n        }\n        const nodes1 = [];\n        const nodes2 = [];\n        var i, j;\n        for (i = 0; i < connections.length; i++) {\n            var connection = connections[i];\n            if (!nodes1.includes(connection.from))\n                nodes1.push(connection.from);\n            if (!nodes2.includes(connection.to))\n                nodes2.push(connection.to);\n        }\n        switch (method) {\n            case methods_1.default.gating.INPUT:\n                for (i = 0; i < nodes2.length; i++) {\n                    let node = nodes2[i];\n                    let gater = this.nodes[i % this.nodes.length];\n                    for (j = 0; j < node.connections.in.length; j++) {\n                        let conn = node.connections.in[j];\n                        if (connections.includes(conn)) {\n                            gater.gate(conn);\n                        }\n                    }\n                }\n                break;\n            case methods_1.default.gating.OUTPUT:\n                for (i = 0; i < nodes1.length; i++) {\n                    let node = nodes1[i];\n                    let gater = this.nodes[i % this.nodes.length];\n                    for (j = 0; j < node.connections.out.length; j++) {\n                        let conn = node.connections.out[j];\n                        if (connections.includes(conn)) {\n                            gater.gate(conn);\n                        }\n                    }\n                }\n                break;\n            case methods_1.default.gating.SELF:\n                for (i = 0; i < nodes1.length; i++) {\n                    let node = nodes1[i];\n                    let gater = this.nodes[i % this.nodes.length];\n                    if (connections.includes(node.connections.self)) {\n                        gater.gate(node.connections.self);\n                    }\n                }\n        }\n    }\n    /**\n     * Sets the value of a property for every node\n     */\n    set(values) {\n        for (var i = 0; i < this.nodes.length; i++) {\n            if (typeof values.bias !== 'undefined') {\n                this.nodes[i].bias = values.bias;\n            }\n            this.nodes[i].squash = values.squash || this.nodes[i].squash;\n            this.nodes[i].type = values.type || this.nodes[i].type;\n        }\n    }\n    disconnect(target, twosided = false) {\n        // In the future, disconnect will return a connection so indexOf can be used\n        var i, j, k;\n        if (target instanceof Group) {\n            for (i = 0; i < this.nodes.length; i++) {\n                for (j = 0; j < target.nodes.length; j++) {\n                    this.nodes[i].disconnect(target.nodes[j], twosided);\n                    for (k = this.connections.out.length - 1; k >= 0; k--) {\n                        let conn = this.connections.out[k];\n                        if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\n                            this.connections.out.splice(k, 1);\n                            break;\n                        }\n                    }\n                    if (twosided) {\n                        for (k = this.connections.in.length - 1; k >= 0; k--) {\n                            let conn = this.connections.in[k];\n                            if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\n                                this.connections.in.splice(k, 1);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            for (i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].disconnect(target, twosided);\n                for (j = this.connections.out.length - 1; j >= 0; j--) {\n                    let conn = this.connections.out[j];\n                    if (conn.from === this.nodes[i] && conn.to === target) {\n                        this.connections.out.splice(j, 1);\n                        break;\n                    }\n                }\n                if (twosided) {\n                    for (j = this.connections.in.length - 1; j >= 0; j--) {\n                        var conn = this.connections.in[j];\n                        if (conn.from === target && conn.to === this.nodes[i]) {\n                            this.connections.in.splice(j, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Clear the context of this group\n     */\n    clear() {\n        for (var i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].clear();\n        }\n    }\n}\nexports[\"default\"] = Group;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/group.ts?");

/***/ }),

/***/ "./src/architecture/layer.ts":
/*!***********************************!*\
  !*** ./src/architecture/layer.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst group_1 = __importDefault(__webpack_require__(/*! ./group */ \"./src/architecture/group.ts\"));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"./src/architecture/node.ts\"));\n/* Import */\nconst methods_1 = __importDefault(__webpack_require__(/*! ../methods/methods */ \"./src/methods/methods.ts\"));\nconst node_type_enum_1 = __webpack_require__(/*! ../types/node-type-enum */ \"./src/types/node-type-enum.ts\");\nclass Layer {\n    constructor() {\n        this.output = null;\n        this.nodes = [];\n        this.connections = { in: [], out: [], self: [] };\n        this.input = (() => {\n        });\n    }\n    /**\n     * Activates all the nodes in the group\n     */\n    activate(value) {\n        var values = [];\n        if (typeof value !== \"undefined\" && value.length !== this.nodes.length) {\n            throw new Error(\"Array with values should be same as the amount of nodes!\");\n        }\n        for (var i = 0; i < this.nodes.length; i++) {\n            var activation;\n            if (typeof value === \"undefined\") {\n                activation = this.nodes[i].activate();\n            }\n            else {\n                activation = this.nodes[i].activate(value[i]);\n            }\n            values.push(activation);\n        }\n        return values;\n    }\n    /**\n     * Propagates all the node in the group\n     */\n    propagate(rate, momentum, target) {\n        if (typeof target !== \"undefined\" && target.length !== this.nodes.length) {\n            throw new Error(\"Array with values should be same as the amount of nodes!\");\n        }\n        for (var i = this.nodes.length - 1; i >= 0; i--) {\n            if (typeof target === \"undefined\") {\n                this.nodes[i].propagate(rate, momentum, true);\n            }\n            else {\n                this.nodes[i].propagate(rate, momentum, true, target[i]);\n            }\n        }\n    }\n    /**\n     * Connects the nodes in this group to nodes in another group or just a node\n     */\n    connect(target, method, weight) {\n        var connections;\n        if (target instanceof group_1.default || target instanceof node_1.default) {\n            connections = this.output.connect(target, method, weight);\n        }\n        else {\n            connections = target.input(this, method, weight);\n        }\n        return connections;\n    }\n    /**\n     * Make nodes from this group gate the given connection(s)\n     */\n    gate(connections, method) {\n        this.output.gate(connections, method);\n    }\n    /**\n     * Sets the value of a property for every node\n     */\n    set(values) {\n        for (var i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (node instanceof node_1.default) {\n                if (typeof values.bias !== \"undefined\") {\n                    node.bias = values.bias;\n                }\n                node.squash = values.squash || node.squash;\n                node.type = values.type || node.type;\n            }\n            else {\n                node.set(values);\n            }\n        }\n    }\n    /**\n     * Disconnects all nodes from this group from another given group/node\n     */\n    disconnect(target, twosided = false) {\n        // In the future, disconnect will return a connection so indexOf can be used\n        var i, j, k;\n        if (target instanceof group_1.default) {\n            for (i = 0; i < this.nodes.length; i++) {\n                for (j = 0; j < target.nodes.length; j++) {\n                    this.nodes[i].disconnect(target.nodes[j], twosided);\n                    for (k = this.connections.out.length - 1; k >= 0; k--) {\n                        let conn = this.connections.out[k];\n                        if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\n                            this.connections.out.splice(k, 1);\n                            break;\n                        }\n                    }\n                    if (twosided) {\n                        for (k = this.connections.in.length - 1; k >= 0; k--) {\n                            let conn = this.connections.in[k];\n                            if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\n                                this.connections.in.splice(k, 1);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            for (i = 0; i < this.nodes.length; i++) {\n                this.nodes[i].disconnect(target, twosided);\n                for (j = this.connections.out.length - 1; j >= 0; j--) {\n                    let conn = this.connections.out[j];\n                    if (conn.from === this.nodes[i] && conn.to === target) {\n                        this.connections.out.splice(j, 1);\n                        break;\n                    }\n                }\n                if (twosided) {\n                    for (k = this.connections.in.length - 1; k >= 0; k--) {\n                        let conn = this.connections.in[k];\n                        if (conn.from === target && conn.to === this.nodes[i]) {\n                            this.connections.in.splice(k, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Clear the context of this group\n     */\n    clear() {\n        for (var i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].clear();\n        }\n    }\n    static Dense(size) {\n        // Create the layer\n        var layer = new Layer();\n        // Init required nodes (in activation order)\n        var block = new group_1.default(size);\n        layer.nodes.push(block);\n        layer.output = block;\n        layer.input = function (from, method, weight) {\n            method = method || methods_1.default.connection.ALL_TO_ALL;\n            return from.connect(block, method, weight);\n        };\n        return layer;\n    }\n    static LSTM(size) {\n        // Create the layer\n        var layer = new Layer();\n        // Init required nodes (in activation order)\n        var inputGate = new group_1.default(size);\n        var forgetGate = new group_1.default(size);\n        var memoryCell = new group_1.default(size);\n        var outputGate = new group_1.default(size);\n        var outputBlock = new group_1.default(size);\n        inputGate.set({\n            bias: 1,\n        });\n        forgetGate.set({\n            bias: 1,\n        });\n        outputGate.set({\n            bias: 1,\n        });\n        // Set up internal connections\n        memoryCell.connect(inputGate, methods_1.default.connection.ALL_TO_ALL);\n        memoryCell.connect(forgetGate, methods_1.default.connection.ALL_TO_ALL);\n        memoryCell.connect(outputGate, methods_1.default.connection.ALL_TO_ALL);\n        var forget = memoryCell.connect(memoryCell, methods_1.default.connection.ONE_TO_ONE);\n        var output = memoryCell.connect(outputBlock, methods_1.default.connection.ALL_TO_ALL);\n        // Set up gates\n        forgetGate.gate(forget, methods_1.default.gating.SELF);\n        outputGate.gate(output, methods_1.default.gating.OUTPUT);\n        // Add to nodes array\n        layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock];\n        // Define output\n        layer.output = outputBlock;\n        layer.input = function (from, method, weight) {\n            method = method || methods_1.default.connection.ALL_TO_ALL;\n            var connections = [];\n            var input = from.connect(memoryCell, method, weight);\n            connections = connections.concat(input);\n            connections = connections.concat(from.connect(inputGate, method, weight));\n            connections = connections.concat(from.connect(outputGate, method, weight));\n            connections = connections.concat(from.connect(forgetGate, method, weight));\n            inputGate.gate(input, methods_1.default.gating.INPUT);\n            return connections;\n        };\n        return layer;\n    }\n    static GRU(size) {\n        // Create the layer\n        var layer = new Layer();\n        var updateGate = new group_1.default(size);\n        var inverseUpdateGate = new group_1.default(size);\n        var resetGate = new group_1.default(size);\n        var memoryCell = new group_1.default(size);\n        var output = new group_1.default(size);\n        var previousOutput = new group_1.default(size);\n        previousOutput.set({\n            bias: 0,\n            squash: methods_1.default.activation.IDENTITY,\n            type: node_type_enum_1.NodeTypeEnum.constant,\n        });\n        memoryCell.set({\n            squash: methods_1.default.activation.TANH,\n        });\n        inverseUpdateGate.set({\n            bias: 0,\n            squash: methods_1.default.activation.INVERSE,\n            type: node_type_enum_1.NodeTypeEnum.constant,\n        });\n        updateGate.set({\n            bias: 1,\n        });\n        resetGate.set({\n            bias: 0,\n        });\n        // Update gate calculation\n        previousOutput.connect(updateGate, methods_1.default.connection.ALL_TO_ALL);\n        // Inverse update gate calculation\n        updateGate.connect(inverseUpdateGate, methods_1.default.connection.ONE_TO_ONE, 1);\n        // Reset gate calculation\n        previousOutput.connect(resetGate, methods_1.default.connection.ALL_TO_ALL);\n        // Memory calculation\n        var reset = previousOutput.connect(memoryCell, methods_1.default.connection.ALL_TO_ALL);\n        resetGate.gate(reset, methods_1.default.gating.OUTPUT); // gate\n        // Output calculation\n        var update1 = previousOutput.connect(output, methods_1.default.connection.ALL_TO_ALL);\n        var update2 = memoryCell.connect(output, methods_1.default.connection.ALL_TO_ALL);\n        updateGate.gate(update1, methods_1.default.gating.OUTPUT);\n        inverseUpdateGate.gate(update2, methods_1.default.gating.OUTPUT);\n        // Previous output calculation\n        output.connect(previousOutput, methods_1.default.connection.ONE_TO_ONE, 1);\n        // Add to nodes array\n        layer.nodes = [\n            updateGate,\n            inverseUpdateGate,\n            resetGate,\n            memoryCell,\n            output,\n            previousOutput,\n        ];\n        layer.output = output;\n        layer.input = function (from, method, weight) {\n            if (from instanceof Layer)\n                from = from.output;\n            method = method || methods_1.default.connection.ALL_TO_ALL;\n            var connections = [];\n            connections = connections.concat(from.connect(updateGate, method, weight));\n            connections = connections.concat(from.connect(resetGate, method, weight));\n            connections = connections.concat(from.connect(memoryCell, method, weight));\n            return connections;\n        };\n        return layer;\n    }\n    static Memory(size, memory) {\n        // Create the layer\n        var layer = new Layer();\n        // Because the output can only be one group, we have to put the nodes all in óne group\n        var previous = null;\n        var i;\n        for (i = 0; i < memory; i++) {\n            var block = new group_1.default(size);\n            block.set({\n                squash: methods_1.default.activation.IDENTITY,\n                bias: 0,\n                type: node_type_enum_1.NodeTypeEnum.constant,\n            });\n            if (previous != null) {\n                previous.connect(block, methods_1.default.connection.ONE_TO_ONE, 1);\n            }\n            layer.nodes.push(block);\n            previous = block;\n        }\n        layer.nodes.reverse();\n        for (i = 0; i < layer.nodes.length; i++) {\n            layer.nodes[i].nodes.reverse();\n        }\n        // Because output can only be óne group, fit all memory nodes in óne group\n        var outputGroup = new group_1.default(0);\n        for (var group in layer.nodes) {\n            outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);\n        }\n        layer.output = outputGroup;\n        layer.input = function (from, method, weight) {\n            if (from instanceof Layer)\n                from = from.output;\n            method = method || methods_1.default.connection.ALL_TO_ALL;\n            if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {\n                throw new Error(\"Previous layer size must be same as memory size\");\n            }\n            return from.connect(layer.nodes[layer.nodes.length - 1], method, weight\n            // methods.connection.ONE_TO_ONE,\n            // 1\n            );\n        };\n        return layer;\n    }\n}\nexports[\"default\"] = Layer;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/layer.ts?");

/***/ }),

/***/ "./src/architecture/network.ts":
/*!*************************************!*\
  !*** ./src/architecture/network.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst connection_1 = __importDefault(__webpack_require__(/*! ./connection */ \"./src/architecture/connection.ts\"));\nconst node_1 = __importDefault(__webpack_require__(/*! ./node */ \"./src/architecture/node.ts\"));\n/* Import */\nconst multi = __importStar(__webpack_require__(/*! ../multithreading/multi */ \"./src/multithreading/multi.ts\"));\nconst methods_1 = __importDefault(__webpack_require__(/*! ../methods/methods */ \"./src/methods/methods.ts\"));\nconst config_1 = __importDefault(__webpack_require__(/*! ../config */ \"./src/config.ts\"));\nconst neat_1 = __importDefault(__webpack_require__(/*! ../neat */ \"./src/neat.ts\"));\nconst node_type_enum_1 = __webpack_require__(/*! ../types/node-type-enum */ \"./src/types/node-type-enum.ts\");\nconst sub_node_1 = __importDefault(__webpack_require__(/*! ../methods/mutation/sub-node */ \"./src/methods/mutation/sub-node.ts\"));\nclass Network {\n    constructor(input, output) {\n        if (typeof input === 'undefined' || typeof output === 'undefined') {\n            throw new Error('No input or output size given');\n        }\n        this.input = input;\n        this.output = output;\n        // Store all the node and connection genes\n        this.nodes = []; // Stored in activation order\n        this.connections = [];\n        this.gates = [];\n        this.selfconns = [];\n        this.isEvolvingStopped = false;\n        // Regularization\n        this.dropout = 0;\n        // Create input and output nodes\n        for (let i = 0; i < this.input + this.output; i++) {\n            var type = i < this.input ? node_type_enum_1.NodeTypeEnum.input : node_type_enum_1.NodeTypeEnum.output;\n            this.nodes.push(new node_1.default(type));\n        }\n        // Connect input nodes with output nodes directly\n        for (let i = 0; i < this.input; i++) {\n            for (var j = this.input; j < this.output + this.input; j++) {\n                // https://stats.stackexchange.com/a/248040/147931\n                var weight = Math.random() * this.input * Math.sqrt(2 / this.input);\n                this.connect(this.nodes[i], this.nodes[j], weight);\n            }\n        }\n    }\n    /**\n     * Activates the network\n     */\n    activate(input, training) {\n        var output = [];\n        // Activate nodes chronologically\n        for (var i = 0; i < this.nodes.length; i++) {\n            if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.input) {\n                this.nodes[i].activate(input[i]);\n            }\n            else if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.output) {\n                var activation = this.nodes[i].activate();\n                output.push(activation);\n            }\n            else {\n                if (training)\n                    this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;\n                this.nodes[i].activate();\n            }\n        }\n        return output;\n    }\n    /**\n     * Activates the network without calculating elegibility traces and such\n     */\n    noTraceActivate(input) {\n        var output = [];\n        // Activate nodes chronologically\n        for (var i = 0; i < this.nodes.length; i++) {\n            if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.input) {\n                this.nodes[i].noTraceActivate(input[i]);\n            }\n            else if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.output) {\n                var activation = this.nodes[i].noTraceActivate();\n                output.push(activation);\n            }\n            else {\n                this.nodes[i].noTraceActivate();\n            }\n        }\n        return output;\n    }\n    /**\n     * Backpropagate the network\n     */\n    propagate(rate, momentum, update, target) {\n        if (typeof target === 'undefined' || target.length !== this.output) {\n            throw new Error('Output target length should match network output length');\n        }\n        var targetIndex = target.length;\n        // Propagate output nodes\n        var i;\n        for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {\n            this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);\n        }\n        // Propagate hidden and input nodes\n        for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {\n            this.nodes[i].propagate(rate, momentum, update);\n        }\n    }\n    /**\n     * Clear the context of the network\n     */\n    clear() {\n        for (var i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].clear();\n        }\n    }\n    /**\n     * Connects the from node to the to node\n     */\n    connect(from, to, weight) {\n        const connections = from.connect(to, weight);\n        for (let i = 0; i < connections.length; i++) {\n            const connection = connections[i];\n            if (from !== to) {\n                this.connections.push(connection);\n            }\n            else {\n                this.selfconns.push(connection);\n            }\n        }\n        return connections;\n    }\n    /**\n     * Disconnects the from node from the to node\n     */\n    disconnect(from, to) {\n        // Delete the connection in the network's connection array\n        var connections = from === to ? this.selfconns : this.connections;\n        for (var i = 0; i < connections.length; i++) {\n            var connection = connections[i];\n            if (connection.from === from && connection.to === to) {\n                if (connection.gater !== null)\n                    this.ungate(connection);\n                connections.splice(i, 1);\n                break;\n            }\n        }\n        // Delete the connection at the sending and receiving neuron\n        from.disconnect(to);\n    }\n    /**\n     * Gate a connection with a node\n     */\n    gate(node, connection) {\n        if (this.nodes.indexOf(node) === -1) {\n            throw new Error('This node is not part of the network!');\n        }\n        else if (connection.gater != null) {\n            if (config_1.default.warnings)\n                console.warn('This connection is already gated!');\n            return;\n        }\n        node.gate(connection);\n        this.gates.push(connection);\n    }\n    /**\n     *  Remove the gate of a connection\n     */\n    ungate(connection) {\n        var _a;\n        var index = this.gates.indexOf(connection);\n        if (index === -1) {\n            throw new Error('This connection is not gated!');\n        }\n        this.gates.splice(index, 1);\n        (_a = connection.gater) === null || _a === void 0 ? void 0 : _a.ungate(connection);\n    }\n    /**\n     *  Removes a node from the network\n     */\n    remove(node) {\n        var index = this.nodes.indexOf(node);\n        if (index === -1) {\n            throw new Error('This node does not exist in the network!');\n        }\n        // Keep track of gaters\n        var gaters = [];\n        // Remove selfconnections from this.selfconns\n        this.disconnect(node, node);\n        // Get all its inputting nodes\n        var inputs = [];\n        for (var i = node.connections.in.length - 1; i >= 0; i--) {\n            let connection = node.connections.in[i];\n            if (sub_node_1.default.keep_gates && connection.gater !== null && connection.gater !== node) {\n                gaters.push(connection.gater);\n            }\n            inputs.push(connection.from);\n            this.disconnect(connection.from, node);\n        }\n        // Get all its outputing nodes\n        var outputs = [];\n        for (i = node.connections.out.length - 1; i >= 0; i--) {\n            let connection = node.connections.out[i];\n            if (sub_node_1.default.keep_gates && connection.gater !== null && connection.gater !== node) {\n                gaters.push(connection.gater);\n            }\n            outputs.push(connection.to);\n            this.disconnect(node, connection.to);\n        }\n        // Connect the input nodes to the output nodes (if not already connected)\n        var connections = [];\n        for (i = 0; i < inputs.length; i++) {\n            let input = inputs[i];\n            for (var j = 0; j < outputs.length; j++) {\n                let output = outputs[j];\n                if (!input.isProjectingTo(output)) {\n                    var conn = this.connect(input, output);\n                    connections.push(conn[0]);\n                }\n            }\n        }\n        // Gate random connections with gaters\n        for (i = 0; i < gaters.length; i++) {\n            if (connections.length === 0)\n                break;\n            let gater = gaters[i];\n            let connIndex = Math.floor(Math.random() * connections.length);\n            this.gate(gater, connections[connIndex]);\n            connections.splice(connIndex, 1);\n        }\n        // Remove gated connections gated by this node\n        for (i = node.connections.gated.length - 1; i >= 0; i--) {\n            let conn = node.connections.gated[i];\n            this.ungate(conn);\n        }\n        // Remove selfconnection\n        this.disconnect(node, node);\n        // Remove the node from this.nodes\n        this.nodes.splice(index, 1);\n    }\n    /**\n     * Mutates the network with the given method\n     */\n    mutate(method) {\n        if (typeof method === 'undefined') {\n            throw new Error('No (correct) mutate method given!');\n        }\n        method.callback(this);\n    }\n    /**\n     * Train the given set to this network\n     */\n    train(set, options = {}) {\n        if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\n            throw new Error('Dataset input/output size should be same as network input/output size!');\n        }\n        // Warning messages\n        if (typeof options.rate === 'undefined') {\n            if (config_1.default.warnings)\n                console.warn('Using default learning rate, please define a rate!');\n        }\n        if (typeof options.iterations === 'undefined') {\n            if (config_1.default.warnings)\n                console.warn('No target iterations given, running until error is reached!');\n        }\n        // Read the options\n        var targetError = options.error || 0.05;\n        var cost = options.cost || methods_1.default.cost.MSE;\n        var baseRate = options.rate || 0.3;\n        var dropout = options.dropout || 0;\n        var momentum = options.momentum || 0;\n        var batchSize = options.batchSize || 1; // online learning\n        var ratePolicy = options.ratePolicy || methods_1.default.rate.FIXED();\n        var start = Date.now();\n        if (batchSize > set.length) {\n            throw new Error('Batch size must be smaller or equal to dataset length!');\n        }\n        else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\n            throw new Error('At least one of the following options must be specified: error, iterations');\n        }\n        else if (typeof options.error === 'undefined') {\n            targetError = -1; // run until iterations\n        }\n        else if (typeof options.iterations === 'undefined') {\n            options.iterations = 0; // run until target error\n        }\n        // Save to network\n        this.dropout = dropout;\n        let trainSet = [], testSet = [];\n        if (options.crossValidate) {\n            let numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);\n            trainSet = set.slice(0, numTrain);\n            testSet = set.slice(numTrain);\n        }\n        // Loops the training process\n        var currentRate = baseRate;\n        var iteration = 0;\n        var error = 1;\n        // var i, j, x;\n        while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {\n            if (options.crossValidate && error <= options.crossValidate.testError)\n                break;\n            iteration++;\n            // Update the rate\n            currentRate = ratePolicy(baseRate, iteration);\n            // Checks if cross validation is enabled\n            if (options.crossValidate) {\n                this._trainSet(trainSet, batchSize, currentRate, momentum, cost);\n                if (options.clear)\n                    this.clear();\n                error = this.test(testSet, cost).error;\n                if (options.clear)\n                    this.clear();\n            }\n            else {\n                error = this._trainSet(set, batchSize, currentRate, momentum, cost);\n                if (options.clear)\n                    this.clear();\n            }\n            // Checks for options such as scheduled logs and shuffling\n            if (options.shuffle) {\n                for (let j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x)\n                    ;\n            }\n            if (options.log && iteration % options.log === 0) {\n                console.log('iteration', iteration, 'error', error, 'rate', currentRate);\n            }\n            if (options.schedule && iteration % options.schedule.iterations === 0) {\n                options.schedule.function({ error: error, iteration: iteration });\n            }\n        }\n        if (options.clear)\n            this.clear();\n        if (dropout) {\n            for (let i = 0; i < this.nodes.length; i++) {\n                if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.hidden || this.nodes[i].type === node_type_enum_1.NodeTypeEnum.constant) {\n                    this.nodes[i].mask = 1 - this.dropout;\n                }\n            }\n        }\n        return {\n            error: error,\n            iterations: iteration,\n            time: Date.now() - start\n        };\n    }\n    /**\n     * Performs one training epoch and returns the error\n     * private function used in this.train\n     */\n    _trainSet(set, batchSize, currentRate, momentum, costFunction) {\n        let errorSum = 0;\n        for (var i = 0; i < set.length; i++) {\n            const input = set[i].input;\n            const target = set[i].output;\n            const update = ((i + 1) % batchSize === 0 || (i + 1) === set.length);\n            const output = this.activate(input, true);\n            this.propagate(currentRate, momentum, update, target);\n            errorSum += costFunction(target, output);\n        }\n        return errorSum / set.length;\n    }\n    /**\n     * Tests a set and returns the error and elapsed time\n     */\n    test(set, cost = methods_1.default.cost.MSE) {\n        // Check if dropout is enabled, set correct mask\n        var i;\n        if (this.dropout) {\n            for (i = 0; i < this.nodes.length; i++) {\n                if (this.nodes[i].type === node_type_enum_1.NodeTypeEnum.hidden || this.nodes[i].type === node_type_enum_1.NodeTypeEnum.constant) {\n                    this.nodes[i].mask = 1 - this.dropout;\n                }\n            }\n        }\n        var error = 0;\n        var start = Date.now();\n        for (i = 0; i < set.length; i++) {\n            let input = set[i].input;\n            let target = set[i].output;\n            let output = this.noTraceActivate(input);\n            error += cost(target, output);\n        }\n        error /= set.length;\n        return {\n            error: error,\n            time: Date.now() - start\n        };\n    }\n    /**\n     * Convert the network to a json object\n     */\n    toJSON() {\n        var json = {\n            nodes: [],\n            connections: [],\n            input: this.input,\n            output: this.output,\n            dropout: this.dropout\n        };\n        // So we don't have to use expensive .indexOf()\n        for (let i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].index = i;\n        }\n        for (let i = 0; i < this.nodes.length; i++) {\n            let node = this.nodes[i];\n            let tojson = node.toJSON();\n            tojson.index = i;\n            json.nodes.push(tojson);\n            if (node.connections.self.weight !== 0) {\n                let tojson = node.connections.self.toJSON();\n                tojson.from = i;\n                tojson.to = i;\n                tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;\n                json.connections.push(tojson);\n            }\n        }\n        for (let i = 0; i < this.connections.length; i++) {\n            let conn = this.connections[i];\n            let tojson = conn.toJSON();\n            tojson.from = conn.from.index;\n            tojson.to = conn.to.index;\n            tojson.gater = conn.gater != null ? conn.gater.index : null;\n            json.connections.push(tojson);\n        }\n        return json;\n    }\n    /**\n     * Sets the value of a property for every node in this network\n     */\n    set(values) {\n        for (var i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].bias = values.bias || this.nodes[i].bias;\n            this.nodes[i].squash = values.squash || this.nodes[i].squash;\n        }\n    }\n    stopEvolve() {\n        this.isEvolvingStopped = true;\n        return this.evolvingPromise;\n    }\n    /**\n     * Evolves the network to reach a lower error on a dataset\n     */\n    evolve(set, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\n                throw new Error('Dataset input/output size should be same as network input/output size!');\n            }\n            this.isEvolvingStopped = false;\n            let resolveEvolve;\n            this.evolvingPromise = new Promise((resolve) => {\n                resolveEvolve = resolve;\n            });\n            // Read the options\n            options = options || {};\n            var targetError = typeof options.error !== 'undefined' ? options.error : 0.05;\n            var growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;\n            var cost = options.cost || methods_1.default.cost.MSE;\n            var amount = options.amount || 1;\n            var threads = options.threads;\n            if (typeof threads === 'undefined') {\n                if (typeof window === 'undefined') { // Node.js\n                    threads = (__webpack_require__(/*! os */ \"os\").cpus)().length;\n                }\n                else { // Browser\n                    threads = navigator.hardwareConcurrency;\n                }\n            }\n            var start = Date.now();\n            if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\n                throw new Error('At least one of the following options must be specified: error, iterations');\n            }\n            else if (typeof options.error === 'undefined') {\n                targetError = -1; // run until iterations\n            }\n            else if (typeof options.iterations === 'undefined') {\n                options.iterations = 0; // run until target error\n            }\n            var fitnessFunction;\n            let workers = [];\n            if (typeof window !== 'undefined' && options.browserWorkerScriptUrl == undefined) {\n                threads = 1;\n            }\n            if (threads === 1) {\n                // Create the fitness function\n                fitnessFunction = function (genome) {\n                    var score = 0;\n                    for (var i = 0; i < amount; i++) {\n                        score -= genome.test(set, cost).error;\n                    }\n                    score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\n                    score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection\n                    return score / amount;\n                };\n            }\n            else {\n                // Create workers, send datasets\n                workers = [];\n                if (typeof window === 'undefined') {\n                    for (let i = 0; i < threads; i++) {\n                        workers.push(new multi.workers.node.TestWorker(set, cost));\n                    }\n                }\n                else {\n                    for (let i = 0; i < threads; i++) {\n                        workers.push(new multi.workers.browser.TestWorker(options.browserWorkerScriptUrl, set, cost));\n                    }\n                }\n                fitnessFunction = function (population) {\n                    return new Promise((resolve) => {\n                        // Create a queue\n                        var queue = population.slice();\n                        var done = 0;\n                        // Start worker function\n                        var startWorker = function (worker) {\n                            if (!queue.length) {\n                                if (++done === threads)\n                                    resolve(undefined);\n                                return;\n                            }\n                            var genome = queue.shift();\n                            worker.evaluate(genome).then(function (result) {\n                                genome.score = -result;\n                                genome.score -= (genome.nodes.length - genome.input - genome.output +\n                                    genome.connections.length + genome.gates.length) * growth;\n                                genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;\n                                startWorker(worker);\n                            });\n                        };\n                        for (var i = 0; i < workers.length; i++) {\n                            startWorker(workers[i]);\n                        }\n                    });\n                };\n                options.fitnessPopulation = true;\n            }\n            // Intialise the NEAT instance\n            options.network = this;\n            // @todo: выкосить any\n            var neat = new neat_1.default(this.input, this.output, fitnessFunction, options);\n            var error = -Infinity;\n            var bestFitness = -Infinity;\n            var bestGenome;\n            while (!this.isEvolvingStopped && error < -targetError && (options.iterations === 0 || neat.generation < options.iterations)) {\n                let fittest = yield neat.evolve();\n                let fitness = fittest.score;\n                error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;\n                if (fitness > bestFitness) {\n                    bestFitness = fitness;\n                    bestGenome = fittest;\n                }\n                if (options.log && neat.generation % options.log === 0) {\n                    console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);\n                }\n                if (options.schedule && neat.generation % options.schedule.iterations === 0) {\n                    options.schedule.function({ fitness: fitness, error: -error, iteration: neat.generation });\n                }\n                if (options.callback) {\n                    options.callback(fittest, { fitness: fitness, error: -error, iteration: neat.generation });\n                }\n            }\n            if (threads > 1) {\n                //@ts-ignore\n                for (var i = 0; i < workers.length; i++) {\n                    //@ts-ignore\n                    workers[i].terminate();\n                }\n            }\n            if (typeof bestGenome !== 'undefined') {\n                this.nodes = bestGenome.nodes;\n                this.connections = bestGenome.connections;\n                this.selfconns = bestGenome.selfconns;\n                this.gates = bestGenome.gates;\n                if (options.clear)\n                    this.clear();\n            }\n            const returnResult = {\n                error: -error,\n                iterations: neat.generation,\n                time: Date.now() - start\n            };\n            resolveEvolve(returnResult);\n            return returnResult;\n        });\n    }\n    /**\n     * Creates a standalone function of the network which can be run without the\n     * need of a library\n     */\n    standalone() {\n        var present = [];\n        var activations = [];\n        var states = [];\n        var lines = [];\n        var functions = [];\n        var i;\n        for (i = 0; i < this.input; i++) {\n            var node = this.nodes[i];\n            activations.push(node.activation);\n            states.push(node.state);\n        }\n        lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');\n        // So we don't have to use expensive .indexOf()\n        for (i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].index = i;\n        }\n        for (i = this.input; i < this.nodes.length; i++) {\n            let node = this.nodes[i];\n            activations.push(node.activation);\n            states.push(node.state);\n            var functionIndex = present.indexOf(node.squash.name);\n            if (functionIndex === -1) {\n                functionIndex = present.length;\n                present.push(node.squash.name);\n                functions.push(node.squash.toString());\n            }\n            var incoming = [];\n            for (var j = 0; j < node.connections.in.length; j++) {\n                var conn = node.connections.in[j];\n                var computation = `A[${conn.from.index}] * ${conn.weight}`;\n                if (conn.gater != null) {\n                    computation += ` * A[${conn.gater.index}]`;\n                }\n                incoming.push(computation);\n            }\n            if (node.connections.self.weight) {\n                let conn = node.connections.self;\n                let computation = `S[${i}] * ${conn.weight}`;\n                if (conn.gater != null) {\n                    computation += ` * A[${conn.gater.index}]`;\n                }\n                incoming.push(computation);\n            }\n            var line1 = `S[${i}] = ${incoming.join(' + ')} + ${node.bias};`;\n            var line2 = `A[${i}] = F[${functionIndex}](S[${i}])${!node.mask ? ' * ' + node.mask : ''};`;\n            lines.push(line1);\n            lines.push(line2);\n        }\n        var output = [];\n        for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {\n            output.push(`A[${i}]`);\n        }\n        lines.push(`return [${output.join(',')}];`);\n        var total = '';\n        total += `var F = [${functions.toString()}];\\r\\n`;\n        total += `var A = [${activations.toString()}];\\r\\n`;\n        total += `var S = [${states.toString()}];\\r\\n`;\n        total += `activate = function(input){\\r\\n${lines.join('\\r\\n')}\\r\\n}`;\n        return total;\n    }\n    /**\n     * Serialize to send to workers efficiently\n     */\n    serialize() {\n        var activations = [];\n        var states = [];\n        var conns = [];\n        var squashes = [\n            'LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID',\n            'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH',\n            'ABSOLUTE', 'INVERSE', 'SELU'\n        ];\n        conns.push(this.input);\n        conns.push(this.output);\n        var i;\n        for (i = 0; i < this.nodes.length; i++) {\n            let node = this.nodes[i];\n            node.index = i;\n            activations.push(node.activation);\n            states.push(node.state);\n        }\n        for (i = this.input; i < this.nodes.length; i++) {\n            let node = this.nodes[i];\n            conns.push(node.index);\n            conns.push(node.bias);\n            conns.push(squashes.indexOf(node.squash.name));\n            conns.push(node.connections.self.weight);\n            conns.push(node.connections.self.gater == null ? -1 : node.connections.self.gater.index);\n            for (var j = 0; j < node.connections.in.length; j++) {\n                let conn = node.connections.in[j];\n                conns.push(conn.from.index);\n                conns.push(conn.weight);\n                conns.push(conn.gater == null ? -1 : conn.gater.index);\n            }\n            conns.push(-2); // stop token -> next node\n        }\n        return [activations, states, conns];\n    }\n    /**\n     * Convert a json object to a network\n     */\n    static fromJSON(json) {\n        var network = new Network(json.input, json.output);\n        network.dropout = json.dropout;\n        network.nodes = [];\n        network.connections = [];\n        var i;\n        for (i = 0; i < json.nodes.length; i++) {\n            network.nodes.push(node_1.default.fromJSON(json.nodes[i]));\n        }\n        for (i = 0; i < json.connections.length; i++) {\n            var conn = json.connections[i];\n            var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];\n            connection.weight = conn.weight;\n            if (conn.gater != null) {\n                network.gate(network.nodes[conn.gater], connection);\n            }\n        }\n        return network;\n    }\n    /**\n     * Merge two networks into one\n     */\n    static merge(network1, network2) {\n        // Create a copy of the networks\n        network1 = Network.fromJSON(network1.toJSON());\n        network2 = Network.fromJSON(network2.toJSON());\n        // Check if output and input size are the same\n        if (network1.output !== network2.input) {\n            throw new Error('Output size of network1 should be the same as the input size of network2!');\n        }\n        // Redirect all connections from network2 input from network1 output\n        var i;\n        for (i = 0; i < network2.connections.length; i++) {\n            let conn = network2.connections[i];\n            if (conn.from.type === node_type_enum_1.NodeTypeEnum.input) {\n                let index = network2.nodes.indexOf(conn.from);\n                // redirect\n                conn.from = network1.nodes[network1.nodes.length - 1 - index];\n            }\n        }\n        // Delete input nodes of network2\n        for (i = network2.input - 1; i >= 0; i--) {\n            network2.nodes.splice(i, 1);\n        }\n        // Change the node type of network1's output nodes (now hidden)\n        for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {\n            network1.nodes[i].type = node_type_enum_1.NodeTypeEnum.hidden;\n        }\n        // Create one network from both networks\n        network1.connections = network1.connections.concat(network2.connections);\n        network1.nodes = network1.nodes.concat(network2.nodes);\n        return network1;\n    }\n    /**\n     * Create an offspring from two parent networks\n     */\n    static crossOver(network1, network2, equal) {\n        if (network1.input !== network2.input || network1.output !== network2.output) {\n            throw new Error(\"Networks don't have the same input/output size!\");\n        }\n        // Initialise offspring\n        var offspring = new Network(network1.input, network1.output);\n        offspring.connections = [];\n        offspring.nodes = [];\n        // Save scores and create a copy\n        var score1 = network1.score || 0;\n        var score2 = network2.score || 0;\n        // Determine offspring node size\n        var size;\n        if (equal || score1 === score2) {\n            let max = Math.max(network1.nodes.length, network2.nodes.length);\n            let min = Math.min(network1.nodes.length, network2.nodes.length);\n            size = Math.floor(Math.random() * (max - min + 1) + min);\n        }\n        else if (score1 > score2) {\n            size = network1.nodes.length;\n        }\n        else {\n            size = network2.nodes.length;\n        }\n        // Rename some variables for easier reading\n        var outputSize = network1.output;\n        // Set indexes so we don't need indexOf\n        var i;\n        for (i = 0; i < network1.nodes.length; i++) {\n            network1.nodes[i].index = i;\n        }\n        for (i = 0; i < network2.nodes.length; i++) {\n            network2.nodes[i].index = i;\n        }\n        // Assign nodes from parents to offspring\n        for (i = 0; i < size; i++) {\n            // Determine if an output node is needed\n            var node;\n            if (i < size - outputSize) {\n                let random = Math.random();\n                node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];\n                let other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];\n                if (typeof node === 'undefined' || node.type === node_type_enum_1.NodeTypeEnum.output) {\n                    node = other;\n                }\n            }\n            else {\n                if (Math.random() >= 0.5) {\n                    node = network1.nodes[network1.nodes.length + i - size];\n                }\n                else {\n                    node = network2.nodes[network2.nodes.length + i - size];\n                }\n            }\n            var newNode = new node_1.default();\n            newNode.bias = node.bias;\n            newNode.squash = node.squash;\n            newNode.type = node.type;\n            offspring.nodes.push(newNode);\n        }\n        // Create arrays of connection genes\n        var n1conns = {};\n        var n2conns = {};\n        // Normal connections\n        for (i = 0; i < network1.connections.length; i++) {\n            let conn = network1.connections[i];\n            let data = {\n                weight: conn.weight,\n                from: conn.from.index,\n                to: conn.to.index,\n                gater: conn.gater != null ? conn.gater.index : -1\n            };\n            n1conns[connection_1.default.innovationID(data.from, data.to)] = data;\n        }\n        // Selfconnections\n        for (i = 0; i < network1.selfconns.length; i++) {\n            let conn = network1.selfconns[i];\n            let data = {\n                weight: conn.weight,\n                from: conn.from.index,\n                to: conn.to.index,\n                gater: conn.gater != null ? conn.gater.index : -1\n            };\n            n1conns[connection_1.default.innovationID(data.from, data.to)] = data;\n        }\n        // Normal connections\n        for (i = 0; i < network2.connections.length; i++) {\n            let conn = network2.connections[i];\n            let data = {\n                weight: conn.weight,\n                from: conn.from.index,\n                to: conn.to.index,\n                gater: conn.gater != null ? conn.gater.index : -1\n            };\n            n2conns[connection_1.default.innovationID(data.from, data.to)] = data;\n        }\n        // Selfconnections\n        for (i = 0; i < network2.selfconns.length; i++) {\n            let conn = network2.selfconns[i];\n            let data = {\n                weight: conn.weight,\n                from: conn.from.index,\n                to: conn.to.index,\n                gater: conn.gater != null ? conn.gater.index : -1\n            };\n            n2conns[connection_1.default.innovationID(data.from, data.to)] = data;\n        }\n        // Split common conn genes from disjoint or excess conn genes\n        var connections = [];\n        var keys1 = Object.keys(n1conns);\n        var keys2 = Object.keys(n2conns);\n        for (i = keys1.length - 1; i >= 0; i--) {\n            // Common gene\n            if (typeof n2conns[keys1[i]] !== 'undefined') {\n                let conn = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];\n                connections.push(conn);\n                // Because deleting is expensive, just set it to some value\n                n2conns[keys1[i]] = undefined;\n            }\n            else if (score1 >= score2 || equal) {\n                connections.push(n1conns[keys1[i]]);\n            }\n        }\n        // Excess/disjoint gene\n        if (score2 >= score1 || equal) {\n            for (i = 0; i < keys2.length; i++) {\n                if (typeof n2conns[keys2[i]] !== 'undefined') {\n                    connections.push(n2conns[keys2[i]]);\n                }\n            }\n        }\n        // Add common conn genes uniformly\n        for (i = 0; i < connections.length; i++) {\n            let connData = connections[i];\n            if (connData.to < size && connData.from < size) {\n                let from = offspring.nodes[connData.from];\n                let to = offspring.nodes[connData.to];\n                let conn = offspring.connect(from, to)[0];\n                conn.weight = connData.weight;\n                if (connData.gater !== -1 && connData.gater < size) {\n                    offspring.gate(offspring.nodes[connData.gater], conn);\n                }\n            }\n        }\n        return offspring;\n    }\n}\nexports[\"default\"] = Network;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/network.ts?");

/***/ }),

/***/ "./src/architecture/node.ts":
/*!**********************************!*\
  !*** ./src/architecture/node.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst connection_1 = __importDefault(__webpack_require__(/*! ./connection */ \"./src/architecture/connection.ts\"));\nconst methods_1 = __importDefault(__webpack_require__(/*! ../methods/methods */ \"./src/methods/methods.ts\"));\nconst config_1 = __importDefault(__webpack_require__(/*! ../config */ \"./src/config.ts\"));\nconst node_type_enum_1 = __webpack_require__(/*! ../types/node-type-enum */ \"./src/types/node-type-enum.ts\");\nclass NodeElement {\n    constructor(nodeType) {\n        this.activation = 0;\n        this.derivative = 0;\n        this.state = 0;\n        this.old = 0;\n        this.mask = 1;\n        // For tracking momentum\n        this.previousDeltaBias = 0;\n        // Batch training\n        this.totalDeltaBias = 0;\n        this.error = {\n            responsibility: 0,\n            projected: 0,\n            gated: 0\n        };\n        this.bias = (nodeType === node_type_enum_1.NodeTypeEnum.input) ? 0 : Math.random() * 0.2 - 0.1;\n        this.squash = methods_1.default.activation.LOGISTIC;\n        this.type = nodeType || node_type_enum_1.NodeTypeEnum.hidden;\n        this.connections = {\n            in: [],\n            out: [],\n            gated: [],\n            self: new connection_1.default(this, this, 0)\n        };\n    }\n    /**\n     * Activates the node\n     */\n    activate(input) {\n        // Check if an input is given\n        if (typeof input !== 'undefined') {\n            this.activation = input;\n            return this.activation;\n        }\n        this.old = this.state;\n        // All activation sources coming from the node itself\n        this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\n        // Activation sources coming from connections\n        for (let i = 0; i < this.connections.in.length; i++) {\n            var connection = this.connections.in[i];\n            this.state += connection.from.activation * connection.weight * connection.gain;\n        }\n        // Squash the values received\n        this.activation = this.squash(this.state) * this.mask;\n        this.derivative = this.squash(this.state, true);\n        // Update traces\n        var nodes = [];\n        var influences = [];\n        for (let i = 0; i < this.connections.gated.length; i++) {\n            let conn = this.connections.gated[i];\n            let node = conn.to;\n            let index = nodes.indexOf(node);\n            if (index > -1) {\n                influences[index] += conn.weight * conn.from.activation;\n            }\n            else {\n                nodes.push(node);\n                influences.push(conn.weight * conn.from.activation +\n                    (node.connections.self.gater === this ? node.old : 0));\n            }\n            // Adjust the gain to this nodes' activation\n            conn.gain = this.activation;\n        }\n        for (let i = 0; i < this.connections.in.length; i++) {\n            let connection = this.connections.in[i];\n            // Elegibility trace\n            connection.elegibility = this.connections.self.gain * this.connections.self.weight *\n                connection.elegibility + connection.from.activation * connection.gain;\n            // Extended trace\n            for (var j = 0; j < nodes.length; j++) {\n                let node = nodes[j];\n                let influence = influences[j];\n                let index = connection.xtrace.nodes.indexOf(node);\n                if (index > -1) {\n                    connection.xtrace.values[index] = node.connections.self.gain * node.connections.self.weight *\n                        connection.xtrace.values[index] + this.derivative * connection.elegibility * influence;\n                }\n                else {\n                    // Does not exist there yet, might be through mutation\n                    connection.xtrace.nodes.push(node);\n                    connection.xtrace.values.push(this.derivative * connection.elegibility * influence);\n                }\n            }\n        }\n        return this.activation;\n    }\n    /**\n     * Activates the node without calculating elegibility traces and such\n     */\n    noTraceActivate(input) {\n        // Check if an input is given\n        if (typeof input !== 'undefined') {\n            this.activation = input;\n            return this.activation;\n        }\n        // All activation sources coming from the node itself\n        this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias;\n        // Activation sources coming from connections\n        var i;\n        for (i = 0; i < this.connections.in.length; i++) {\n            var connection = this.connections.in[i];\n            this.state += connection.from.activation * connection.weight * connection.gain;\n        }\n        // Squash the values received\n        this.activation = this.squash(this.state);\n        for (i = 0; i < this.connections.gated.length; i++) {\n            this.connections.gated[i].gain = this.activation;\n        }\n        return this.activation;\n    }\n    /**\n     * Back-propagate the error, aka learn\n     */\n    propagate(rate = 0.3, momentum = 0, update, target) {\n        //    momentum = momentum || 0;\n        //    rate = rate || 0.3;\n        // Error accumulator\n        let error = 0;\n        // Output nodes get their error from the enviroment\n        if (this.type === node_type_enum_1.NodeTypeEnum.output) {\n            this.error.responsibility = this.error.projected = (target || 0) - this.activation;\n        }\n        else { // the rest of the nodes compute their error responsibilities by backpropagation\n            // error responsibilities from all the connections projected from this node\n            for (let i = 0; i < this.connections.out.length; i++) {\n                let connection = this.connections.out[i];\n                let node = connection.to;\n                // Eq. 21\n                error += node.error.responsibility * connection.weight * connection.gain;\n            }\n            // Projected error responsibility\n            this.error.projected = this.derivative * error;\n            // Error responsibilities from all connections gated by this neuron\n            error = 0;\n            for (let i = 0; i < this.connections.gated.length; i++) {\n                let conn = this.connections.gated[i];\n                let node = conn.to;\n                let influence = node.connections.self.gater === this ? node.old : 0;\n                influence += conn.weight * conn.from.activation;\n                error += node.error.responsibility * influence;\n            }\n            // Gated error responsibility\n            this.error.gated = this.derivative * error;\n            // Error responsibility\n            this.error.responsibility = this.error.projected + this.error.gated;\n        }\n        if (this.type === node_type_enum_1.NodeTypeEnum.constant)\n            return;\n        // Adjust all the node's incoming connections\n        for (let i = 0; i < this.connections.in.length; i++) {\n            let connection = this.connections.in[i];\n            let gradient = this.error.projected * connection.elegibility;\n            for (var j = 0; j < connection.xtrace.nodes.length; j++) {\n                let node = connection.xtrace.nodes[j];\n                let value = connection.xtrace.values[j];\n                gradient += node.error.responsibility * value;\n            }\n            // Adjust weight\n            let deltaWeight = rate * gradient * this.mask;\n            connection.totalDeltaWeight += deltaWeight;\n            if (update) {\n                connection.totalDeltaWeight += momentum * connection.previousDeltaWeight;\n                connection.weight += connection.totalDeltaWeight;\n                connection.previousDeltaWeight = connection.totalDeltaWeight;\n                connection.totalDeltaWeight = 0;\n            }\n        }\n        // Adjust bias\n        const deltaBias = rate * this.error.responsibility;\n        this.totalDeltaBias += deltaBias;\n        if (update) {\n            this.totalDeltaBias += momentum * this.previousDeltaBias;\n            this.bias += this.totalDeltaBias;\n            this.previousDeltaBias = this.totalDeltaBias;\n            this.totalDeltaBias = 0;\n        }\n    }\n    /**\n     * Creates a connection from this node to the given node\n     */\n    connect(target, weight) {\n        const connections = [];\n        if (typeof target.bias !== 'undefined') { // must be a node!\n            target = target;\n            if (target === this) {\n                // Turn on the self connection by setting the weight\n                if (this.connections.self.weight !== 0) {\n                    if (config_1.default.warnings)\n                        console.warn('This connection already exists!');\n                }\n                else {\n                    this.connections.self.weight = weight || 1;\n                }\n                connections.push(this.connections.self);\n            }\n            else if (this.isProjectingTo(target)) {\n                throw new Error('Already projecting a connection to this node!');\n            }\n            else {\n                let connection = new connection_1.default(this, target, weight);\n                target.connections.in.push(connection);\n                this.connections.out.push(connection);\n                connections.push(connection);\n            }\n        }\n        else { // should be a group\n            target = target;\n            for (var i = 0; i < target.nodes.length; i++) {\n                let connection = new connection_1.default(this, target.nodes[i], weight);\n                target.nodes[i].connections.in.push(connection);\n                this.connections.out.push(connection);\n                target.connections.in.push(connection);\n                connections.push(connection);\n            }\n        }\n        return connections;\n    }\n    /**\n     * Disconnects this node from the other node\n     */\n    disconnect(node, twosided) {\n        if (this === node) {\n            this.connections.self.weight = 0;\n            return;\n        }\n        for (let i = 0; i < this.connections.out.length; i++) {\n            let conn = this.connections.out[i];\n            if (conn.to === node) {\n                this.connections.out.splice(i, 1);\n                let j = conn.to.connections.in.indexOf(conn);\n                conn.to.connections.in.splice(j, 1);\n                if (conn.gater !== null)\n                    conn.gater.ungate(conn);\n                break;\n            }\n        }\n        if (twosided) {\n            node.disconnect(this);\n        }\n    }\n    /**\n     * Make this node gate a connection\n     */\n    gate(connections) {\n        if (!Array.isArray(connections)) {\n            connections = [connections];\n        }\n        for (let i = 0; i < connections.length; i++) {\n            let connection = connections[i];\n            this.connections.gated.push(connection);\n            connection.gater = this;\n        }\n    }\n    /**\n     * Removes the gates from this node from the given connection(s)\n     */\n    ungate(connections) {\n        if (!Array.isArray(connections)) {\n            connections = [connections];\n        }\n        for (var i = connections.length - 1; i >= 0; i--) {\n            var connection = connections[i];\n            var index = this.connections.gated.indexOf(connection);\n            this.connections.gated.splice(index, 1);\n            connection.gater = null;\n            connection.gain = 1;\n        }\n    }\n    /**\n     * Clear the context of the node\n     */\n    clear() {\n        for (var i = 0; i < this.connections.in.length; i++) {\n            var connection = this.connections.in[i];\n            connection.elegibility = 0;\n            connection.xtrace = {\n                nodes: [],\n                values: []\n            };\n        }\n        for (i = 0; i < this.connections.gated.length; i++) {\n            let conn = this.connections.gated[i];\n            conn.gain = 0;\n        }\n        this.error.responsibility = this.error.projected = this.error.gated = 0;\n        this.old = this.state = this.activation = 0;\n    }\n    /**\n     * Checks if this node is projecting to the given node\n     */\n    isProjectingTo(node) {\n        if (node === this && this.connections.self.weight !== 0)\n            return true;\n        for (var i = 0; i < this.connections.out.length; i++) {\n            var conn = this.connections.out[i];\n            if (conn.to === node) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if the given node is projecting to this node\n     */\n    isProjectedBy(node) {\n        if (node === this && this.connections.self.weight !== 0)\n            return true;\n        for (var i = 0; i < this.connections.in.length; i++) {\n            var conn = this.connections.in[i];\n            if (conn.from === node) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Converts the node to a json object\n     */\n    toJSON() {\n        return {\n            bias: this.bias,\n            type: this.type,\n            squash: this.squash.name,\n            mask: this.mask\n        };\n    }\n    /**\n     * @todo: Удалить тип any или сделать валидацию\n     */\n    static fromJSON(json) {\n        var node = new NodeElement();\n        node.bias = json.bias;\n        node.type = json.type;\n        node.mask = json.mask;\n        node.squash = methods_1.default.activation[json.squash];\n        return node;\n    }\n}\nexports[\"default\"] = NodeElement;\n\n\n//# sourceURL=webpack://MasterNeat/./src/architecture/node.ts?");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = {\n    warnings: false\n};\n\n\n//# sourceURL=webpack://MasterNeat/./src/config.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.multi = exports.Neat = exports.NodeElement = exports.Layer = exports.Group = exports.config = exports.Network = exports.architect = exports.Connection = exports.methods = void 0;\nconst methods_1 = __importDefault(__webpack_require__(/*! ./methods/methods */ \"./src/methods/methods.ts\"));\nexports.methods = methods_1.default;\nconst connection_1 = __importDefault(__webpack_require__(/*! ./architecture/connection */ \"./src/architecture/connection.ts\"));\nexports.Connection = connection_1.default;\nconst architect_1 = __importDefault(__webpack_require__(/*! ./architecture/architect */ \"./src/architecture/architect.ts\"));\nexports.architect = architect_1.default;\nconst network_1 = __importDefault(__webpack_require__(/*! ./architecture/network */ \"./src/architecture/network.ts\"));\nexports.Network = network_1.default;\nconst config_1 = __importDefault(__webpack_require__(/*! ./config */ \"./src/config.ts\"));\nexports.config = config_1.default;\nconst group_1 = __importDefault(__webpack_require__(/*! ./architecture/group */ \"./src/architecture/group.ts\"));\nexports.Group = group_1.default;\nconst layer_1 = __importDefault(__webpack_require__(/*! ./architecture/layer */ \"./src/architecture/layer.ts\"));\nexports.Layer = layer_1.default;\nconst node_1 = __importDefault(__webpack_require__(/*! ./architecture/node */ \"./src/architecture/node.ts\"));\nexports.NodeElement = node_1.default;\nconst neat_1 = __importDefault(__webpack_require__(/*! ./neat */ \"./src/neat.ts\"));\nexports.Neat = neat_1.default;\nconst multi = __importStar(__webpack_require__(/*! ./multithreading/multi */ \"./src/multithreading/multi.ts\"));\nexports.multi = multi;\n\n\n//# sourceURL=webpack://MasterNeat/./src/index.ts?");

/***/ }),

/***/ "./src/methods/activation.ts":
/*!***********************************!*\
  !*** ./src/methods/activation.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst activation = {\n    LOGISTIC: (x, derivate) => {\n        const fx = 1 / (1 + Math.exp(-x));\n        if (!derivate)\n            return fx;\n        return fx * (1 - fx);\n    },\n    TANH: function (x, derivate) {\n        if (derivate)\n            return 1 - Math.pow(Math.tanh(x), 2);\n        return Math.tanh(x);\n    },\n    IDENTITY: function (x, derivate) {\n        return derivate ? 1 : x;\n    },\n    STEP: function (x, derivate) {\n        return derivate ? 0 : x > 0 ? 1 : 0;\n    },\n    RELU: function (x, derivate) {\n        if (derivate)\n            return x > 0 ? 1 : 0;\n        return x > 0 ? x : 0;\n    },\n    SOFTSIGN: function (x, derivate) {\n        const d = 1 + Math.abs(x);\n        if (derivate)\n            return x / Math.pow(d, 2);\n        return x / d;\n    },\n    SINUSOID: function (x, derivate) {\n        if (derivate)\n            return Math.cos(x);\n        return Math.sin(x);\n    },\n    GAUSSIAN: function (x, derivate) {\n        const d = Math.exp(-Math.pow(x, 2));\n        if (derivate)\n            return -2 * x * d;\n        return d;\n    },\n    BENT_IDENTITY: function (x, derivate) {\n        const d = Math.sqrt(Math.pow(x, 2) + 1);\n        if (derivate)\n            return x / (2 * d) + 1;\n        return (d - 1) / 2 + x;\n    },\n    BIPOLAR: function (x, derivate) {\n        return derivate ? 0 : x > 0 ? 1 : -1;\n    },\n    BIPOLAR_SIGMOID: function (x, derivate) {\n        const d = 2 / (1 + Math.exp(-x)) - 1;\n        if (derivate)\n            return 1 / 2 * (1 + d) * (1 - d);\n        return d;\n    },\n    HARD_TANH: function (x, derivate) {\n        if (derivate)\n            return x > -1 && x < 1 ? 1 : 0;\n        return Math.max(-1, Math.min(1, x));\n    },\n    ABSOLUTE: function (x, derivate) {\n        if (derivate)\n            return x < 0 ? -1 : 1;\n        return Math.abs(x);\n    },\n    INVERSE: function (x, derivate) {\n        if (derivate)\n            return -1;\n        return 1 - x;\n    },\n    // https://arxiv.org/pdf/1706.02515.pdf\n    SELU: function (x, derivate) {\n        const alpha = 1.6732632423543772848170429916717;\n        const scale = 1.0507009873554804934193349852946;\n        const fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\n        if (derivate) {\n            return x > 0 ? scale : (fx + alpha) * scale;\n        }\n        return fx * scale;\n    }\n};\nexports[\"default\"] = activation;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/activation.ts?");

/***/ }),

/***/ "./src/methods/connection.ts":
/*!***********************************!*\
  !*** ./src/methods/connection.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst connection = {\n    ALL_TO_ALL: {\n        name: 'OUTPUT'\n    },\n    ALL_TO_ELSE: {\n        name: 'INPUT'\n    },\n    ONE_TO_ONE: {\n        name: 'SELF'\n    }\n};\nexports[\"default\"] = connection;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/connection.ts?");

/***/ }),

/***/ "./src/methods/cost.ts":
/*!*****************************!*\
  !*** ./src/methods/cost.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://en.wikipedia.org/wiki/Loss_function\nconst cost = {\n    // Cross entropy error\n    CROSS_ENTROPY: function (target, output) {\n        let error = 0;\n        for (let i = 0; i < output.length; i++) {\n            // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A\n            error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));\n        }\n        return error / output.length;\n    },\n    // Mean Squared Error\n    MSE: function (target, output) {\n        let error = 0;\n        for (let i = 0; i < output.length; i++) {\n            error += Math.pow(target[i] - output[i], 2);\n        }\n        return error / output.length;\n    },\n    // Binary error\n    BINARY: function (target, output) {\n        let misses = 0;\n        for (let i = 0; i < output.length; i++) {\n            misses = misses + Number(Math.round(target[i] * 2) !== Math.round(output[i] * 2));\n        }\n        return misses;\n    },\n    // Mean Absolute Error\n    MAE: function (target, output) {\n        var error = 0;\n        for (var i = 0; i < output.length; i++) {\n            error += Math.abs(target[i] - output[i]);\n        }\n        return error / output.length;\n    },\n    // Mean Absolute Percentage Error\n    MAPE: function (target, output) {\n        var error = 0;\n        for (var i = 0; i < output.length; i++) {\n            error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));\n        }\n        return error / output.length;\n    },\n    // Mean Squared Logarithmic Error\n    MSLE: function (target, output) {\n        var error = 0;\n        for (var i = 0; i < output.length; i++) {\n            error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));\n        }\n        return error;\n    },\n    // Hinge loss, for classifiers\n    HINGE: function (target, output) {\n        var error = 0;\n        for (var i = 0; i < output.length; i++) {\n            error += Math.max(0, 1 - target[i] * output[i]);\n        }\n        return error;\n    }\n};\nexports[\"default\"] = cost;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/cost.ts?");

/***/ }),

/***/ "./src/methods/crossover.ts":
/*!**********************************!*\
  !*** ./src/methods/crossover.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\nconst crossover = {\n    SINGLE_POINT: {\n        name: 'SINGLE_POINT',\n        config: [0.4]\n    },\n    TWO_POINT: {\n        name: 'TWO_POINT',\n        config: [0.4, 0.9]\n    },\n    UNIFORM: {\n        name: 'UNIFORM'\n    },\n    AVERAGE: {\n        name: 'AVERAGE'\n    }\n};\nexports[\"default\"] = crossover;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/crossover.ts?");

/***/ }),

/***/ "./src/methods/gating.ts":
/*!*******************************!*\
  !*** ./src/methods/gating.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Specifies how to gate a connection between two groups of multiple neurons\nconst gating = {\n    OUTPUT: {\n        name: 'OUTPUT'\n    },\n    INPUT: {\n        name: 'INPUT'\n    },\n    SELF: {\n        name: 'SELF'\n    }\n};\nexports[\"default\"] = gating;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/gating.ts?");

/***/ }),

/***/ "./src/methods/methods.ts":
/*!********************************!*\
  !*** ./src/methods/methods.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst activation_1 = __importDefault(__webpack_require__(/*! ./activation */ \"./src/methods/activation.ts\"));\nconst mutation_1 = __importDefault(__webpack_require__(/*! ./mutation */ \"./src/methods/mutation/index.ts\"));\nconst selection_1 = __importDefault(__webpack_require__(/*! ./selection */ \"./src/methods/selection.ts\"));\nconst crossover_1 = __importDefault(__webpack_require__(/*! ./crossover */ \"./src/methods/crossover.ts\"));\nconst cost_1 = __importDefault(__webpack_require__(/*! ./cost */ \"./src/methods/cost.ts\"));\nconst gating_1 = __importDefault(__webpack_require__(/*! ./gating */ \"./src/methods/gating.ts\"));\nconst connection_1 = __importDefault(__webpack_require__(/*! ./connection */ \"./src/methods/connection.ts\"));\nconst rate_1 = __importDefault(__webpack_require__(/*! ./rate */ \"./src/methods/rate.ts\"));\nexports[\"default\"] = {\n    activation: activation_1.default,\n    mutation: mutation_1.default,\n    selection: selection_1.default,\n    crossover: crossover_1.default,\n    cost: cost_1.default,\n    gating: gating_1.default,\n    connection: connection_1.default,\n    rate: rate_1.default\n};\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/methods.ts?");

/***/ }),

/***/ "./src/methods/mutation/add-back-conn.ts":
/*!***********************************************!*\
  !*** ./src/methods/mutation/add-back-conn.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst addBackConn = {\n    name: 'ADD_BACK_CONN',\n    callback(network) {\n        // Create an array of all uncreated (backfed) connections\n        let available = [];\n        for (let i = network.input; i < network.nodes.length; i++) {\n            let node1 = network.nodes[i];\n            for (let j = network.input; j < i; j++) {\n                let node2 = network.nodes[j];\n                if (!node1.isProjectingTo(node2)) {\n                    available.push([node1, node2]);\n                }\n            }\n        }\n        if (available.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more connections to be made!');\n            return;\n        }\n        let pair = available[Math.floor(Math.random() * available.length)];\n        network.connect(pair[0], pair[1]);\n    }\n};\nexports[\"default\"] = addBackConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/add-back-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/add-conn.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/add-conn.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst addConn = {\n    name: 'ADD_CONN',\n    callback(network) {\n        // Create an array of all uncreated (feedforward) connections\n        let available = [];\n        for (let i = 0; i < network.nodes.length - network.output; i++) {\n            let node1 = network.nodes[i];\n            for (let j = Math.max(i + 1, network.input); j < network.nodes.length; j++) {\n                let node2 = network.nodes[j];\n                if (!node1.isProjectingTo(node2))\n                    available.push([node1, node2]);\n            }\n        }\n        if (available.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more connections to be made!');\n            return;\n        }\n        let pair = available[Math.floor(Math.random() * available.length)];\n        network.connect(pair[0], pair[1]);\n    }\n};\nexports[\"default\"] = addConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/add-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/add-gate.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/add-gate.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst addGate = {\n    name: 'ADD_GATE',\n    callback(network) {\n        let allconnections = network.connections.concat(network.selfconns);\n        // Create a list of all non-gated connections\n        let possible = [];\n        for (let i = 0; i < allconnections.length; i++) {\n            let conn = allconnections[i];\n            if (conn.gater === null) {\n                possible.push(conn);\n            }\n        }\n        if (possible.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more connections to gate!');\n            return;\n        }\n        // Select a random gater node and connection, can't be gated by input\n        let index = Math.floor(Math.random() * (network.nodes.length - network.input) + network.input);\n        const node = network.nodes[index];\n        let conn = possible[Math.floor(Math.random() * possible.length)];\n        // Gate the connection with the node\n        network.gate(node, conn);\n    }\n};\nexports[\"default\"] = addGate;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/add-gate.ts?");

/***/ }),

/***/ "./src/methods/mutation/add-node.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/add-node.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst node_1 = __importDefault(__webpack_require__(/*! ../../architecture/node */ \"./src/architecture/node.ts\"));\nconst node_type_enum_1 = __webpack_require__(/*! ../../types/node-type-enum */ \"./src/types/node-type-enum.ts\");\nconst mod_activation_1 = __importDefault(__webpack_require__(/*! ./mod-activation */ \"./src/methods/mutation/mod-activation.ts\"));\nconst addNode = {\n    name: 'ADD_NODE',\n    callback(network) {\n        // Look for an existing connection and place a node in between\n        let connection = network.connections[Math.floor(Math.random() * network.connections.length)];\n        let gater, from, to;\n        if (connection) {\n            gater = connection.gater;\n            from = connection.from;\n            to = connection.to;\n            network.disconnect(from, to);\n        }\n        else {\n            from = network.nodes.find((node) => node.type === node_type_enum_1.NodeTypeEnum.input);\n            to = network.nodes.find((node) => node.type === node_type_enum_1.NodeTypeEnum.output);\n        }\n        // Insert the new node right before the old connection.to\n        let toIndex = network.nodes.indexOf(to);\n        let node = new node_1.default(node_type_enum_1.NodeTypeEnum.hidden);\n        // Random squash function\n        mod_activation_1.default.mutateNode(node);\n        // Place it in this.nodes\n        let minBound = Math.min(toIndex, network.nodes.length - network.output);\n        network.nodes.splice(minBound, 0, node);\n        // Now create two new connections\n        let newConn1 = network.connect(from, node)[0];\n        let newConn2 = network.connect(node, to)[0];\n        // Check if the original connection was gated\n        if (gater != null) {\n            network.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);\n        }\n    }\n};\nexports[\"default\"] = addNode;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/add-node.ts?");

/***/ }),

/***/ "./src/methods/mutation/add-self-conn.ts":
/*!***********************************************!*\
  !*** ./src/methods/mutation/add-self-conn.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst addSelfConn = {\n    name: 'ADD_SELF_CONN',\n    callback(network) {\n        // Check which nodes aren't selfconnected yet\n        let possible = [];\n        for (let i = network.input; i < network.nodes.length; i++) {\n            let node = network.nodes[i];\n            if (node.connections.self.weight === 0) {\n                possible.push(node);\n            }\n        }\n        if (possible.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more self-connections to add!');\n            return;\n        }\n        // Select a random node\n        const node = possible[Math.floor(Math.random() * possible.length)];\n        // Connect it to himself\n        network.connect(node, node);\n    }\n};\nexports[\"default\"] = addSelfConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/add-self-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/index.ts":
/*!***************************************!*\
  !*** ./src/methods/mutation/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst add_node_1 = __importDefault(__webpack_require__(/*! ./add-node */ \"./src/methods/mutation/add-node.ts\"));\nconst sub_node_1 = __importDefault(__webpack_require__(/*! ./sub-node */ \"./src/methods/mutation/sub-node.ts\"));\nconst add_conn_1 = __importDefault(__webpack_require__(/*! ./add-conn */ \"./src/methods/mutation/add-conn.ts\"));\nconst sub_conn_1 = __importDefault(__webpack_require__(/*! ./sub-conn */ \"./src/methods/mutation/sub-conn.ts\"));\nconst mod_weight_1 = __importDefault(__webpack_require__(/*! ./mod-weight */ \"./src/methods/mutation/mod-weight.ts\"));\nconst mod_bias_1 = __importDefault(__webpack_require__(/*! ./mod-bias */ \"./src/methods/mutation/mod-bias.ts\"));\nconst mod_activation_1 = __importDefault(__webpack_require__(/*! ./mod-activation */ \"./src/methods/mutation/mod-activation.ts\"));\nconst add_gate_1 = __importDefault(__webpack_require__(/*! ./add-gate */ \"./src/methods/mutation/add-gate.ts\"));\nconst sub_gate_1 = __importDefault(__webpack_require__(/*! ./sub-gate */ \"./src/methods/mutation/sub-gate.ts\"));\nconst add_self_conn_1 = __importDefault(__webpack_require__(/*! ./add-self-conn */ \"./src/methods/mutation/add-self-conn.ts\"));\nconst sub_self_conn_1 = __importDefault(__webpack_require__(/*! ./sub-self-conn */ \"./src/methods/mutation/sub-self-conn.ts\"));\nconst add_back_conn_1 = __importDefault(__webpack_require__(/*! ./add-back-conn */ \"./src/methods/mutation/add-back-conn.ts\"));\nconst sub_back_conn_1 = __importDefault(__webpack_require__(/*! ./sub-back-conn */ \"./src/methods/mutation/sub-back-conn.ts\"));\nconst swap_nodes_1 = __importDefault(__webpack_require__(/*! ./swap-nodes */ \"./src/methods/mutation/swap-nodes.ts\"));\nconst mutations = {\n    ALL: [\n        add_node_1.default,\n        sub_node_1.default,\n        add_conn_1.default,\n        sub_conn_1.default,\n        mod_weight_1.default,\n        mod_bias_1.default,\n        mod_activation_1.default,\n        add_gate_1.default,\n        sub_gate_1.default,\n        add_self_conn_1.default,\n        sub_self_conn_1.default,\n        add_back_conn_1.default,\n        sub_back_conn_1.default,\n        swap_nodes_1.default\n    ],\n    FFW: [\n        add_node_1.default,\n        sub_node_1.default,\n        add_conn_1.default,\n        sub_conn_1.default,\n        mod_weight_1.default,\n        mod_bias_1.default,\n        mod_activation_1.default,\n        swap_nodes_1.default\n    ]\n};\nexports[\"default\"] = mutations;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/index.ts?");

/***/ }),

/***/ "./src/methods/mutation/mod-activation.ts":
/*!************************************************!*\
  !*** ./src/methods/mutation/mod-activation.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst activation_1 = __importDefault(__webpack_require__(/*! ../activation */ \"./src/methods/activation.ts\"));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst modActivation = {\n    name: 'MOD_ACTIVATION',\n    callback(network) {\n        // Has no effect on input node, so they are excluded\n        if (!this.mutateOutput && network.input + network.output === network.nodes.length) {\n            if (config_1.default.warnings)\n                console.warn('No nodes that allow mutation of activation function');\n            return;\n        }\n        let index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);\n        const node = network.nodes[index];\n        this.mutateNode(node);\n    },\n    mutateNode(node) {\n        node.squash = this.allowed[(this.allowed.indexOf(node.squash) + Math.floor(Math.random() * (this.allowed.length - 1)) + 1) % this.allowed.length];\n    },\n    mutateOutput: true,\n    allowed: [\n        activation_1.default.LOGISTIC,\n        activation_1.default.TANH,\n        activation_1.default.RELU,\n        activation_1.default.IDENTITY,\n        activation_1.default.STEP,\n        activation_1.default.SOFTSIGN,\n        activation_1.default.SINUSOID,\n        activation_1.default.GAUSSIAN,\n        activation_1.default.BENT_IDENTITY,\n        activation_1.default.BIPOLAR,\n        activation_1.default.BIPOLAR_SIGMOID,\n        activation_1.default.HARD_TANH,\n        activation_1.default.ABSOLUTE,\n        activation_1.default.INVERSE,\n        activation_1.default.SELU\n    ]\n};\nexports[\"default\"] = modActivation;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/mod-activation.ts?");

/***/ }),

/***/ "./src/methods/mutation/mod-bias.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/mod-bias.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst modBias = {\n    name: 'MOD_BIAS',\n    callback(network) {\n        // Has no effect on input node, so they are excluded\n        let index = Math.floor(Math.random() * (network.nodes.length - network.input) + network.input);\n        const node = network.nodes[index];\n        this.mutateNode(node);\n    },\n    mutateNode(node) {\n        let modification = Math.random() * (this.max - this.min) + this.min;\n        node.bias += modification;\n    },\n    min: -1,\n    max: 1,\n};\nexports[\"default\"] = modBias;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/mod-bias.ts?");

/***/ }),

/***/ "./src/methods/mutation/mod-weight.ts":
/*!********************************************!*\
  !*** ./src/methods/mutation/mod-weight.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst modWeight = {\n    name: 'MOD_WEIGHT',\n    callback(network) {\n        let allconnections = network.connections.concat(network.selfconns);\n        let connection = allconnections[Math.floor(Math.random() * allconnections.length)];\n        if (!connection) {\n            return;\n        }\n        let modification = Math.random() * (this.max - this.min) + this.min;\n        connection.weight += modification;\n    },\n    min: -1,\n    max: 1\n};\nexports[\"default\"] = modWeight;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/mod-weight.ts?");

/***/ }),

/***/ "./src/methods/mutation/sub-back-conn.ts":
/*!***********************************************!*\
  !*** ./src/methods/mutation/sub-back-conn.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst subBackConn = {\n    name: 'SUB_BACK_CONN',\n    callback(network) {\n        // List of possible connections that can be removed\n        let possible = [];\n        for (let i = 0; i < network.connections.length; i++) {\n            let conn = network.connections[i];\n            // Check if it is not disabling a node\n            if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && network.nodes.indexOf(conn.from) > network.nodes.indexOf(conn.to)) {\n                possible.push(conn);\n            }\n        }\n        if (possible.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No connections to remove!');\n            return;\n        }\n        let randomConn = possible[Math.floor(Math.random() * possible.length)];\n        network.disconnect(randomConn.from, randomConn.to);\n    }\n};\nexports[\"default\"] = subBackConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/sub-back-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/sub-conn.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/sub-conn.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst subConn = {\n    name: 'SUB_CONN',\n    callback(network) {\n        // List of possible connections that can be removed\n        let possible = [];\n        for (let i = 0; i < network.connections.length; i++) {\n            let conn = network.connections[i];\n            // Check if it is not disabling a node\n            if (conn.from.connections.out.length > 1 && conn.to.connections.in.length > 1 && network.nodes.indexOf(conn.to) > network.nodes.indexOf(conn.from)) {\n                possible.push(conn);\n            }\n        }\n        if (possible.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No connections to remove!');\n            return;\n        }\n        let randomConn = possible[Math.floor(Math.random() * possible.length)];\n        network.disconnect(randomConn.from, randomConn.to);\n    }\n};\nexports[\"default\"] = subConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/sub-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/sub-gate.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/sub-gate.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst subGate = {\n    name: 'SUB_GATE',\n    callback(network) {\n        // Select a random gated connection\n        if (network.gates.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more connections to ungate!');\n            return;\n        }\n        let index = Math.floor(Math.random() * network.gates.length);\n        let gatedconn = network.gates[index];\n        network.ungate(gatedconn);\n    }\n};\nexports[\"default\"] = subGate;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/sub-gate.ts?");

/***/ }),

/***/ "./src/methods/mutation/sub-node.ts":
/*!******************************************!*\
  !*** ./src/methods/mutation/sub-node.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst subNode = {\n    name: 'SUB_NODE',\n    callback(network) {\n        // Check if there are nodes left to remove\n        if (network.nodes.length === network.input + network.output) {\n            if (config_1.default.warnings)\n                console.warn('No more nodes left to remove!');\n            return;\n        }\n        // Select a node which isn't an input or output node\n        let index = Math.floor(Math.random() * (network.nodes.length - network.output - network.input) + network.input);\n        network.remove(network.nodes[index]);\n    },\n    keep_gates: true\n};\nexports[\"default\"] = subNode;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/sub-node.ts?");

/***/ }),

/***/ "./src/methods/mutation/sub-self-conn.ts":
/*!***********************************************!*\
  !*** ./src/methods/mutation/sub-self-conn.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst subSelfConn = {\n    name: 'SUB_SELF_CONN',\n    callback(network) {\n        if (network.selfconns.length === 0) {\n            if (config_1.default.warnings)\n                console.warn('No more self-connections to remove!');\n            return;\n        }\n        const conn = network.selfconns[Math.floor(Math.random() * network.selfconns.length)];\n        network.disconnect(conn.from, conn.to);\n    }\n};\nexports[\"default\"] = subSelfConn;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/sub-self-conn.ts?");

/***/ }),

/***/ "./src/methods/mutation/swap-nodes.ts":
/*!********************************************!*\
  !*** ./src/methods/mutation/swap-nodes.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! ../../config */ \"./src/config.ts\"));\nconst swapNodes = {\n    name: 'SWAP_NODES',\n    callback(network) {\n        // Has no effect on input node, so they are excluded\n        if ((this.mutateOutput && network.nodes.length - network.input < 2) ||\n            (!this.mutateOutput && network.nodes.length - network.input - network.output < 2)) {\n            if (config_1.default.warnings)\n                console.warn('No nodes that allow swapping of bias and activation function');\n            return;\n        }\n        let index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);\n        let node1 = network.nodes[index];\n        index = Math.floor(Math.random() * (network.nodes.length - (this.mutateOutput ? 0 : network.output) - network.input) + network.input);\n        let node2 = network.nodes[index];\n        let biasTemp = node1.bias;\n        let squashTemp = node1.squash;\n        node1.bias = node2.bias;\n        node1.squash = node2.squash;\n        node2.bias = biasTemp;\n        node2.squash = squashTemp;\n    },\n    mutateOutput: true\n};\nexports[\"default\"] = swapNodes;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/mutation/swap-nodes.ts?");

/***/ }),

/***/ "./src/methods/rate.ts":
/*!*****************************!*\
  !*** ./src/methods/rate.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244\nconst rate = {\n    FIXED: () => {\n        const func = function (baseRate) { return baseRate; };\n        return func;\n    },\n    STEP: (gamma = 0.9, stepSize = 100) => {\n        const func = (baseRate, iteration) => {\n            return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));\n        };\n        return func;\n    },\n    EXP: (gamma = 0.999) => {\n        const func = (baseRate, iteration) => {\n            return baseRate * Math.pow(gamma, iteration);\n        };\n        return func;\n    },\n    INV: (gamma = 0.001, power = 2) => {\n        const func = function (baseRate, iteration) {\n            return baseRate * Math.pow(1 + gamma * iteration, -power);\n        };\n        return func;\n    }\n};\nexports[\"default\"] = rate;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/rate.ts?");

/***/ }),

/***/ "./src/methods/selection.ts":
/*!**********************************!*\
  !*** ./src/methods/selection.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)\nconst selection = {\n    FITNESS_PROPORTIONATE: {\n        name: 'FITNESS_PROPORTIONATE'\n    },\n    POWER: {\n        name: 'POWER',\n        power: 4\n    },\n    TOURNAMENT: {\n        name: 'TOURNAMENT',\n        size: 5,\n        probability: 0.5\n    }\n};\nexports[\"default\"] = selection;\n\n\n//# sourceURL=webpack://MasterNeat/./src/methods/selection.ts?");

/***/ }),

/***/ "./src/multithreading/multi.ts":
/*!*************************************!*\
  !*** ./src/multithreading/multi.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.activations = exports.workers = void 0;\nexports.serializeDataSet = serializeDataSet;\nexports.activateSerializedNetwork = activateSerializedNetwork;\nexports.deserializeDataSet = deserializeDataSet;\nexports.testSerializedSet = testSerializedSet;\nconst workers_1 = __importDefault(__webpack_require__(/*! ./workers/workers */ \"./src/multithreading/workers/workers.ts\"));\nexports.workers = workers_1.default;\nfunction serializeDataSet(dataSet) {\n    var serialized = [dataSet[0].input.length, dataSet[0].output.length];\n    for (var i = 0; i < dataSet.length; i++) {\n        var j;\n        for (j = 0; j < serialized[0]; j++) {\n            serialized.push(dataSet[i].input[j]);\n        }\n        for (j = 0; j < serialized[1]; j++) {\n            serialized.push(dataSet[i].output[j]);\n        }\n    }\n    return serialized;\n}\n/**\n * Activate a serialized network\n * @todo: выкосить типы any\n */\nfunction activateSerializedNetwork(input, A, S, data, F) {\n    for (var i = 0; i < data[0]; i++) {\n        A[i] = input[i];\n    }\n    for (i = 2; i < data.length; i++) {\n        let index = data[i++];\n        let bias = data[i++];\n        let squash = data[i++];\n        let selfweight = data[i++];\n        let selfgater = data[i++];\n        S[index] =\n            (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\n        while (data[i] !== -2) {\n            S[index] +=\n                A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\n        }\n        A[index] = F[squash](S[index]);\n    }\n    var output = [];\n    for (i = A.length - data[1]; i < A.length; i++)\n        output.push(A[i]);\n    return output;\n}\n/** Deserializes a dataset to an array of arrays */\nfunction deserializeDataSet(serializedSet) {\n    var set = [];\n    var sampleSize = serializedSet[0] + serializedSet[1];\n    for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\n        let input = [];\n        for (var j = 2 + i * sampleSize; j < 2 + i * sampleSize + serializedSet[0]; j++) {\n            input.push(serializedSet[j]);\n        }\n        let output = [];\n        for (j = 2 + i * sampleSize + serializedSet[0]; j < 2 + i * sampleSize + sampleSize; j++) {\n            output.push(serializedSet[j]);\n        }\n        set.push(input);\n        set.push(output);\n    }\n    return set;\n}\n/** A list of compiled activation functions in a certain order */\nexports.activations = [\n    function (x) {\n        return 1 / (1 + Math.exp(-x));\n    },\n    function (x) {\n        return Math.tanh(x);\n    },\n    function (x) {\n        return x;\n    },\n    function (x) {\n        return x > 0 ? 1 : 0;\n    },\n    function (x) {\n        return x > 0 ? x : 0;\n    },\n    function (x) {\n        return x / (1 + Math.abs(x));\n    },\n    function (x) {\n        return Math.sin(x);\n    },\n    function (x) {\n        return Math.exp(-Math.pow(x, 2));\n    },\n    function (x) {\n        return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x;\n    },\n    function (x) {\n        return x > 0 ? 1 : -1;\n    },\n    function (x) {\n        return 2 / (1 + Math.exp(-x)) - 1;\n    },\n    function (x) {\n        return Math.max(-1, Math.min(1, x));\n    },\n    function (x) {\n        return Math.abs(x);\n    },\n    function (x) {\n        return 1 - x;\n    },\n    function (x) {\n        var a = 1.6732632423543772848170429916717;\n        return ((x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946);\n    },\n];\nfunction testSerializedSet(set, cost, A, S, data, F) {\n    // Calculate how much samples are in the set\n    var error = 0;\n    for (var i = 0; i < set.length; i += 2) {\n        let output = activateSerializedNetwork(set[i], A, S, data, F);\n        error += cost(set[i + 1], output);\n    }\n    return error / (set.length / 2);\n}\n\n\n//# sourceURL=webpack://MasterNeat/./src/multithreading/multi.ts?");

/***/ }),

/***/ "./src/multithreading/workers/browser/testworker.ts":
/*!**********************************************************!*\
  !*** ./src/multithreading/workers/browser/testworker.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst workers_1 = __webpack_require__(/*! ../workers */ \"./src/multithreading/workers/workers.ts\");\n/*******************************************************************************\n WEBWORKER\n *******************************************************************************/\nclass BrowserTestWorker {\n    constructor(workerUrl, dataSet, cost) {\n        this.url = workerUrl;\n        this.worker = new Worker(this.url);\n        const msgPayload = {\n            type: workers_1.EWokerMessageType.init,\n            dataSet: dataSet,\n            cost: cost.name\n        };\n        this.worker.postMessage(msgPayload);\n    }\n    evaluate(network) {\n        return new Promise((resolve) => {\n            const msgPayload = {\n                type: workers_1.EWokerMessageType.iteration,\n                network: network.toJSON()\n            };\n            this.worker.onmessage = function (e) {\n                var error = new Float64Array(e.data.buffer)[0];\n                resolve(error);\n            };\n            this.worker.postMessage(msgPayload);\n        });\n    }\n    terminate() {\n        this.worker.terminate();\n        window.URL.revokeObjectURL(this.url);\n    }\n}\nexports[\"default\"] = BrowserTestWorker;\n\n\n//# sourceURL=webpack://MasterNeat/./src/multithreading/workers/browser/testworker.ts?");

/***/ }),

/***/ "./src/multithreading/workers/node/testworker.ts":
/*!*******************************************************!*\
  !*** ./src/multithreading/workers/node/testworker.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst child_process_1 = __importDefault(__webpack_require__(/*! child_process */ \"child_process\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"));\nconst workers_1 = __webpack_require__(/*! ../workers */ \"./src/multithreading/workers/workers.ts\");\nclass NodeTestWorker {\n    // @todo: выкосить any\n    constructor(dataSet, cost) {\n        if ( true && '.ts' in eval('require.extensions')) {\n            this.worker = child_process_1.default.fork(path_1.default.join(__dirname, '/worker.ts'), [], { execArgv: ['-r', 'ts-node/register'] });\n        }\n        else {\n            this.worker = child_process_1.default.fork(path_1.default.join(process.env.PWD, './dist/worker.js'));\n        }\n        const msgPayload = {\n            type: workers_1.EWokerMessageType.init,\n            dataSet: dataSet,\n            cost: cost.name\n        };\n        this.worker.send(msgPayload);\n    }\n    evaluate(network) {\n        return new Promise((resolve) => {\n            const msgPayload = {\n                type: workers_1.EWokerMessageType.iteration,\n                network: network.toJSON()\n            };\n            var _that = this.worker;\n            this.worker.on('message', function callback(e) {\n                _that.removeListener('message', callback);\n                resolve(e);\n            });\n            this.worker.send(msgPayload);\n        });\n    }\n    terminate() {\n        this.worker.kill();\n    }\n}\nexports[\"default\"] = NodeTestWorker;\n\n\n//# sourceURL=webpack://MasterNeat/./src/multithreading/workers/node/testworker.ts?");

/***/ }),

/***/ "./src/multithreading/workers/workers.ts":
/*!***********************************************!*\
  !*** ./src/multithreading/workers/workers.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EWokerMessageType = void 0;\nconst testworker_1 = __importDefault(__webpack_require__(/*! ./node/testworker */ \"./src/multithreading/workers/node/testworker.ts\"));\nconst testworker_2 = __importDefault(__webpack_require__(/*! ./browser/testworker */ \"./src/multithreading/workers/browser/testworker.ts\"));\nvar EWokerMessageType;\n(function (EWokerMessageType) {\n    EWokerMessageType[\"init\"] = \"init\";\n    EWokerMessageType[\"iteration\"] = \"iteration\";\n})(EWokerMessageType || (exports.EWokerMessageType = EWokerMessageType = {}));\nconst workers = {\n    node: {\n        TestWorker: testworker_1.default\n    },\n    browser: {\n        TestWorker: testworker_2.default\n    }\n};\nexports[\"default\"] = workers;\n\n\n//# sourceURL=webpack://MasterNeat/./src/multithreading/workers/workers.ts?");

/***/ }),

/***/ "./src/neat.ts":
/*!*********************!*\
  !*** ./src/neat.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst network_1 = __importDefault(__webpack_require__(/*! ./architecture/network */ \"./src/architecture/network.ts\"));\nconst methods_1 = __importDefault(__webpack_require__(/*! ./methods/methods */ \"./src/methods/methods.ts\"));\nconst config_1 = __importDefault(__webpack_require__(/*! ./config */ \"./src/config.ts\"));\nconst add_node_1 = __importDefault(__webpack_require__(/*! ./methods/mutation/add-node */ \"./src/methods/mutation/add-node.ts\"));\nconst add_conn_1 = __importDefault(__webpack_require__(/*! ./methods/mutation/add-conn */ \"./src/methods/mutation/add-conn.ts\"));\nconst add_gate_1 = __importDefault(__webpack_require__(/*! ./methods/mutation/add-gate */ \"./src/methods/mutation/add-gate.ts\"));\n/* Easier variable naming */\nvar selection = methods_1.default.selection;\nclass Neat {\n    constructor(input, output, fitness, options) {\n        this.population = [];\n        this.input = input; // The input size of the networks\n        this.output = output; // The output size of the networks\n        this.fitness = fitness; // The fitness function to evaluate the networks\n        // Configure options\n        options = options || {};\n        this.equal = options.equal || false;\n        this.clear = options.clear || false;\n        this.popsize = options.popsize || 50;\n        this.elitism = options.elitism || 0;\n        this.provenance = options.provenance || 0;\n        this.mutationRate = options.mutationRate || 0.3;\n        this.mutationAmount = options.mutationAmount || 1;\n        this.fitnessPopulation = options.fitnessPopulation || false;\n        this.selection = options.selection || methods_1.default.selection.POWER;\n        this.crossover = options.crossover || [\n            methods_1.default.crossover.SINGLE_POINT,\n            methods_1.default.crossover.TWO_POINT,\n            methods_1.default.crossover.UNIFORM,\n            methods_1.default.crossover.AVERAGE\n        ];\n        this.mutation = options.mutation || methods_1.default.mutation.FFW;\n        this.template = options.network || undefined;\n        this.maxNodes = options.maxNodes || Infinity;\n        this.maxConns = options.maxConns || Infinity;\n        this.maxGates = options.maxGates || Infinity;\n        // Custom mutation selection function if given\n        this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod;\n        // Generation counter\n        this.generation = 0;\n        // Initialise the genomes\n        this.createPool(this.template);\n    }\n    /**\n     * Create the initial pool of genomes\n     */\n    createPool(network) {\n        this.population = [];\n        for (var i = 0; i < this.popsize; i++) {\n            var copy;\n            if (this.template) {\n                copy = network_1.default.fromJSON(network.toJSON());\n            }\n            else {\n                copy = new network_1.default(this.input, this.output);\n            }\n            copy.score = undefined;\n            this.population.push(copy);\n        }\n    }\n    /**\n     * Evaluates, selects, breeds and mutates population\n     */\n    evolve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check if evaluated, sort the population\n            if (typeof this.population[this.population.length - 1].score === 'undefined') {\n                yield this.evaluate();\n            }\n            this.sort();\n            var fittest = network_1.default.fromJSON(this.population[0].toJSON());\n            fittest.score = this.population[0].score;\n            var newPopulation = [];\n            // Elitism\n            var elitists = [];\n            for (var i = 0; i < this.elitism; i++) {\n                elitists.push(this.population[i]);\n            }\n            // Provenance\n            for (i = 0; i < this.provenance; i++) {\n                newPopulation.push(network_1.default.fromJSON(this.template.toJSON()));\n            }\n            // Breed the next individuals\n            for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {\n                newPopulation.push(this.getOffspring());\n            }\n            // Replace the old population with the new population\n            this.population = newPopulation;\n            this.mutate();\n            this.population.push(...elitists);\n            // Reset the scores\n            for (i = 0; i < this.population.length; i++) {\n                this.population[i].score = undefined;\n            }\n            this.generation++;\n            return fittest;\n        });\n    }\n    /**\n     * Breeds two parents into an offspring, population MUST be surted\n     */\n    getOffspring() {\n        var parent1 = this.getParent();\n        var parent2 = this.getParent();\n        return network_1.default.crossOver(parent1, parent2, this.equal);\n    }\n    /**\n     * Selects a random mutation method for a genome according to the parameters\n     */\n    selectMutationMethod(genome) {\n        var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];\n        if (mutationMethod === add_node_1.default && genome.nodes.length >= this.maxNodes) {\n            if (config_1.default.warnings)\n                console.warn('maxNodes exceeded!');\n            return;\n        }\n        if (mutationMethod === add_conn_1.default && genome.connections.length >= this.maxConns) {\n            if (config_1.default.warnings)\n                console.warn('maxConns exceeded!');\n            return;\n        }\n        if (mutationMethod === add_gate_1.default && genome.gates.length >= this.maxGates) {\n            if (config_1.default.warnings)\n                console.warn('maxGates exceeded!');\n            return;\n        }\n        return mutationMethod;\n    }\n    /**\n     * Mutates the given (or current) population\n     */\n    mutate() {\n        // Elitist genomes should not be included\n        for (var i = 0; i < this.population.length; i++) {\n            if (Math.random() <= this.mutationRate) {\n                for (var j = 0; j < this.mutationAmount; j++) {\n                    const mutationMethod = this.selectMutationMethod(this.population[i]);\n                    this.population[i].mutate(mutationMethod);\n                }\n            }\n        }\n    }\n    /**\n     * Evaluates the current population\n     */\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var i;\n            if (this.fitnessPopulation) {\n                if (this.clear) {\n                    for (i = 0; i < this.population.length; i++) {\n                        this.population[i].clear();\n                    }\n                }\n                yield this.fitness(this.population);\n            }\n            else {\n                for (i = 0; i < this.population.length; i++) {\n                    var genome = this.population[i];\n                    if (this.clear) {\n                        genome.clear();\n                    }\n                    genome.score = yield this.fitness(genome);\n                }\n            }\n        });\n    }\n    /**\n     * Sorts the population by score\n     */\n    sort() {\n        this.population.sort(function (a, b) {\n            // @ts-ignore\n            return b.score - a.score;\n        });\n    }\n    /**\n     * Returns the fittest genome of the current population\n     */\n    getFittest() {\n        // Check if evaluated\n        if (typeof this.population[this.population.length - 1].score === 'undefined') {\n            this.evaluate();\n        }\n        // @ts-ignore\n        if (this.population[0].score < this.population[1].score) {\n            this.sort();\n        }\n        return this.population[0];\n    }\n    /**\n     * Returns the average fitness of the current population\n     */\n    getAverage() {\n        if (typeof this.population[this.population.length - 1].score === 'undefined') {\n            this.evaluate();\n        }\n        var score = 0;\n        for (var i = 0; i < this.population.length; i++) {\n            // @ts-ignore\n            score += this.population[i].score;\n        }\n        return score / this.population.length;\n    }\n    /**\n     * Gets a genome based on the selection function\n     * @return {Network} genome\n     */\n    getParent() {\n        var i;\n        switch (this.selection.name) {\n            case selection.POWER.name:\n                // @ts-ignore\n                if (this.population[0].score < this.population[1].score)\n                    this.sort();\n                var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);\n                return this.population[index];\n            case selection.FITNESS_PROPORTIONATE.name:\n                // As negative fitnesses are possible\n                // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values\n                // this is unnecessarily run for every individual, should be changed\n                var totalFitness = 0;\n                var minimalFitness = 0;\n                for (i = 0; i < this.population.length; i++) {\n                    var score = this.population[i].score;\n                    minimalFitness = score < minimalFitness ? score : minimalFitness;\n                    totalFitness += score;\n                }\n                minimalFitness = Math.abs(minimalFitness);\n                totalFitness += minimalFitness * this.population.length;\n                var random = Math.random() * totalFitness;\n                var value = 0;\n                for (i = 0; i < this.population.length; i++) {\n                    let genome = this.population[i];\n                    value += genome.score + minimalFitness;\n                    if (random < value)\n                        return genome;\n                }\n                // if all scores equal, return random genome\n                return this.population[Math.floor(Math.random() * this.population.length)];\n            case selection.TOURNAMENT.name:\n                if (this.selection.size > this.popsize) {\n                    throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');\n                }\n                // Create a tournament\n                var individuals = [];\n                for (i = 0; i < this.selection.size; i++) {\n                    let random = this.population[Math.floor(Math.random() * this.population.length)];\n                    individuals.push(random);\n                }\n                // Sort the tournament individuals by score\n                individuals.sort(function (a, b) {\n                    // @ts-ignore\n                    return b.score - a.score;\n                });\n                // Select an individual\n                for (i = 0; i < this.selection.size; i++) {\n                    if (Math.random() < this.selection.probability || i === this.selection.size - 1) {\n                        return individuals[i];\n                    }\n                }\n        }\n    }\n    /**\n     * Export the current population to a json object\n     */\n    export() {\n        var json = [];\n        for (var i = 0; i < this.population.length; i++) {\n            var genome = this.population[i];\n            json.push(genome.toJSON());\n        }\n        return json;\n    }\n    /**\n     * Import population from a json object\n     */\n    import(json) {\n        var population = [];\n        for (var i = 0; i < json.length; i++) {\n            var genome = json[i];\n            population.push(network_1.default.fromJSON(genome));\n        }\n        this.population = population;\n        this.popsize = population.length;\n    }\n}\nexports[\"default\"] = Neat;\n\n\n//# sourceURL=webpack://MasterNeat/./src/neat.ts?");

/***/ }),

/***/ "./src/types/node-type-enum.ts":
/*!*************************************!*\
  !*** ./src/types/node-type-enum.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodeTypeEnum = void 0;\nvar NodeTypeEnum;\n(function (NodeTypeEnum) {\n    NodeTypeEnum[\"input\"] = \"input\";\n    NodeTypeEnum[\"hidden\"] = \"hidden\";\n    NodeTypeEnum[\"output\"] = \"output\";\n    NodeTypeEnum[\"constant\"] = \"constant\";\n})(NodeTypeEnum || (exports.NodeTypeEnum = NodeTypeEnum = {}));\n\n\n//# sourceURL=webpack://MasterNeat/./src/types/node-type-enum.ts?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	exports.MasterNeat = __webpack_exports__;
/******/ 	
/******/ })()
;